<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="java培训笔记  java">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2022/08/01/java%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="java培训笔记  java">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2013/12/ZSSDMld.png">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2013/12/662E827A-FA32-4464-B0BD-40087F429E98.jpg">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2022/03/ascii-1-1.png">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2022/03/ascii-2-1.png">
<meta property="og:image" content="http://example.com/img/jvm.png">
<meta property="og:image" content="http://example.com/img/jvm1.png">
<meta property="og:image" content="http://example.com/..%5Cimg%5Cjvm3.png">
<meta property="og:image" content="http://example.com/..%5Cimg%5Cjvm4.png">
<meta property="og:image" content="http://example.com/img/jvm5.png">
<meta property="og:image" content="http://example.com/img/static.png">
<meta property="og:image" content="http://example.com/img/map.png">
<meta property="og:image" content="http://example.com/2022/08/01/img/regex.png">
<meta property="og:image" content="http://example.com/img/%E6%B3%9B%E5%9E%8B.png">
<meta property="og:image" content="http://example.com/img/%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%9C%E7%94%A8.png">
<meta property="og:image" content="http://example.com/img/%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8.png">
<meta property="og:image" content="http://example.com/img/%E6%B3%9B%E5%9E%8B%E7%B1%BB.png">
<meta property="og:image" content="http://example.com/2022/08/01/img/泛型接口.png">
<meta property="og:image" content="http://example.com/img/%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95.png">
<meta property="og:image" content="http://example.com/img/%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6.png">
<meta property="og:image" content="http://example.com/img/Collection.png">
<meta property="og:image" content="http://example.com/img/Map1.png">
<meta property="og:image" content="http://example.com/img/HashSet&HashMap.png">
<meta property="article:published_time" content="2022-08-01T02:01:44.239Z">
<meta property="article:modified_time" content="2022-08-18T01:47:05.812Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.runoob.com/wp-content/uploads/2013/12/ZSSDMld.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-java培训笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/01/java%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-08-01T02:01:44.239Z" itemprop="datePublished">2022-08-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 color="red">java培训笔记</h1>

<p>java</p>
<span id="more"></span>

<h1 id="Day01-简介"><a href="#Day01-简介" class="headerlink" title="Day01(简介)"></a>Day01(简介)</h1><blockquote>
<p>Day01(简介) </p>
<p>java的概述 </p>
<p>java的三大平台 </p>
<p>java的特点 </p>
<p>java的运行机制 </p>
<p>java的开发环境 </p>
<p>安装JDK </p>
<p>DOS常用命令 </p>
<p>HelloWorld编写 </p>
<p>配置环境变量 </p>
<p>Notepad++编辑工具 </p>
<p>注释</p>
<p>代码解释 </p>
<p>常量</p>
<p>转义字符 </p>
<p>输出不换行 </p>
<p>计算机中的存储单元 </p>
<p>基本数据类型 </p>
<p>变量</p>
<p>运算符</p>
<p>算数运算符 </p>
<p>作业</p>
<p>Eclipse开发工具介绍 </p>
<p>Eclipse开发工具的下载,安装,卸载 </p>
<p>Eclipse使用 </p>
<p>Eclipse快捷键 </p>
</blockquote>
<h2 id="java的概述"><a href="#java的概述" class="headerlink" title="java的概述"></a>java的概述</h2><blockquote>
<p>​		Java是一种面向对象的程序设计语言，由Sun（太阳微电 </p>
<p>子，Sun Microsystems）公司的James Gosling等人于 </p>
<p>1990年代初开发。它最初被命名为Oak</p>
<p>​		在1995年5月以”Java”的名称正式发布了。Java伴 </p>
<p>随着Internet的迅猛发展而发展，逐渐成为重要的Internet </p>
<p>编程语言,2009年4月20日这个曾经高达2,000亿美元的市 </p>
<p>值sun公司以74亿美元的价格被Oracle收购 </p>
</blockquote>
<h2 id="java的三大平台"><a href="#java的三大平台" class="headerlink" title="java的三大平台"></a>java的三大平台</h2><blockquote>
<ul>
<li><p>Java ME (java的微型版本) 应用于移动设备,机顶盒,汽车 </p>
<p>导航系统等 </p>
</li>
<li><p>Java SE (java的标准版本) 应用于桌面操作系统 </p>
</li>
<li><p>Java EE (java的企业版本) 应用于互联网大型系统,基于 </p>
<p>web</p>
</li>
</ul>
</blockquote>
<h2 id="java的特点"><a href="#java的特点" class="headerlink" title="java的特点"></a>java的特点</h2><blockquote>
<ul>
<li><p>语言的简单性(类似于c或者c++,但是没有比较难以理解的 </p>
<p>指针部分) </p>
</li>
<li><p>面向对象(更加方便的去理解,以及继承了面向对象的好处, </p>
</li>
<li><p>如代码扩展和代码的复用) </p>
</li>
<li><p>跨平台特性(一次编写,到处运行) </p>
</li>
<li><p>成熟的多线程模型（优势在于处理高并发）</p>
</li>
</ul>
</blockquote>
<h2 id="java的运行机制"><a href="#java的运行机制" class="headerlink" title="java的运行机制"></a>java的运行机制</h2><blockquote>
<ol>
<li>需要我们编写带有后缀名为java的文件 </li>
<li>使用命令将我们编写的java文件进行编译,编译成.class文 件,即字节码文件 </li>
<li>使用命令将.class文件交给虚拟机,让虚拟机去执行 </li>
<li>虚拟机会做相应的合法安全检查判断 通过检查后,然后由虚拟机解释执行为不同平台计 算机对应的机器码去执行</li>
<li>如果不能通过合法性的检测,虚拟机就会执行相应 的异常程序 </li>
<li>意义在于实现了跨平台++++</li>
</ol>
</blockquote>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/ZSSDMld.png"></p>
<h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><blockquote>
<p>public 表示类的修饰符,修饰的类的名字必须和文件名称 </p>
<p>相同</p>
<p>class 表示类 </p>
<p>HelloWorld 类名(标识符) </p>
<p>main方法 </p>
<p>关键字(java赋予特殊意义的单词) </p>
<p>都是小写字母</p>
</blockquote>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/662E827A-FA32-4464-B0BD-40087F429E98.jpg"></p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>分为4类8种</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>关键字</th>
<th align="center">内存中占用字节数</th>
<th>取值范围</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td>布尔型</td>
<td>boolean</td>
<td align="center">1</td>
<td>true&#x2F;false</td>
<td align="center">FALSE</td>
</tr>
<tr>
<td>字节型</td>
<td>byte</td>
<td align="center">1</td>
<td>-128~127</td>
<td align="center">0</td>
</tr>
<tr>
<td>短整型</td>
<td>short</td>
<td align="center">2</td>
<td>-2^15~2^15-1</td>
<td align="center">0</td>
</tr>
<tr>
<td>整型</td>
<td>int</td>
<td align="center">4</td>
<td>-2^31~2^31-1</td>
<td align="center">0</td>
</tr>
<tr>
<td>长整型</td>
<td>long</td>
<td align="center">8</td>
<td>-2^63~2^63-1</td>
<td align="center">0</td>
</tr>
<tr>
<td>字符型</td>
<td>char</td>
<td align="center">2</td>
<td>0~2^16-1</td>
<td align="center">‘\u000’</td>
</tr>
<tr>
<td>单精度浮点型</td>
<td>float</td>
<td align="center">4</td>
<td>1.4013E-45~3.4028E+38</td>
<td align="center">0.0F</td>
</tr>
<tr>
<td>双精度浮点型</td>
<td>double</td>
<td align="center">8</td>
<td>4.9E-324~1.7977E+308</td>
<td align="center">0.0D</td>
</tr>
</tbody></table>
<h2 id="运算符与优先级"><a href="#运算符与优先级" class="headerlink" title="运算符与优先级"></a>运算符与优先级</h2><blockquote>
<ol>
<li><p>算术运算符： + ， - ， * ， &#x2F; , % , ++ , –</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前缀自增自减法(<span class="strong">**++a,--a**</span>)：先进行自增或者自减运算，再进行表达式运算。</span><br><span class="line">后缀自增自减法(<span class="strong">**a++,a--**</span>)：先进行表达式运算，再进行自增或者自减运算。</span><br></pre></td></tr></table></figure>
</li>
<li><p>赋值运算符： &#x3D;</p>
</li>
<li><p>关系运算符： &gt; , &lt; , &gt;&#x3D; , &lt;&#x3D; , &#x3D;&#x3D; ,!&#x3D;, instanceof </p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instanceof是Java中的二元运算符，左边是对象，右边是类；当对象是	右边类或子类所创建对象时，返回true；否则，返回false。</span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑运算符：&amp;&amp; ， || , ！</p>
</li>
<li><p>位运算符：&amp;，| ，^ , ~ , &gt;&gt; , &lt;&lt; , &gt;&gt;&gt;</p>
<table>
<thead>
<tr>
<th align="center">位运算符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;</td>
<td>位与：左右两边的数中的都某一位非0时，输出位为1</td>
</tr>
<tr>
<td align="center">|</td>
<td>位或：左右两边的数中只要的某一位非0时，输出位为1</td>
</tr>
<tr>
<td align="center">^</td>
<td>位异或：左右两边数其中的某一位不相同时，输出位为1</td>
</tr>
<tr>
<td align="center">~</td>
<td>位非：对你操作数的每一位取反</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td>位右移：左边的数按照右移指定的位数，向右移动到指定位置</td>
</tr>
<tr>
<td align="center">&lt;&lt;</td>
<td>位左移：右边的数按照左移指定的位数，向右移动到指定位置</td>
</tr>
<tr>
<td align="center">&gt;&gt;&gt;</td>
<td>位补零右移：左边的数按照右移指定的位数，向右移动到指定位数；用零来填补空缺位置</td>
</tr>
</tbody></table>
</li>
<li><p>条件运算符 ： ?：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x,y,z;</span><br><span class="line">x = <span class="number">6</span>,y = <span class="number">2</span>;</span><br><span class="line">z = x&gt;y ? x-y : x+y;</span><br><span class="line"><span class="comment">//计算 z 的值，首先要判断 x&gt;y 表达的值，如果为 true，z 的值为 x-y；否则 z 的值为 x+y</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展赋值运算符：+&#x3D; ， -&#x3D; ，*&#x3D; ， &#x2F;&#x3D;</p>
</li>
<li><p><strong>数据类型的优先级</strong></p>
<p>低–高：</p>
<p>(byte,short,char)&lt;int&lt;long&lt;float&lt;double</p>
</li>
<li><p><strong>运算符优先级</strong></p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">优先级</th>
<th align="center">运算符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">()</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">! +(正)  -（负） ++ –</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">*  &#x2F;  %</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">+(加)   -（减）</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">&lt;   &lt;&#x3D;   &gt;  &gt;&#x3D;</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">&#x3D;&#x3D;   !&#x3D;</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">^</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">&amp;&amp;</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">||</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">?:</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">&#x3D;  +&#x3D;  -&#x3D;  *&#x3D;  &#x2F;&#x3D;  %&#x3D;</td>
</tr>
</tbody></table>
</blockquote>
<h1 id="Day02-变量"><a href="#Day02-变量" class="headerlink" title="Day02(变量)"></a>Day02(变量)</h1><blockquote>
<p>Day02(变量)</p>
<p>变量作业</p>
<p>基本数据类型的转换 ASCII表</p>
<p>int和char类型数据转换 运算</p>
<p>符</p>
<p>算数运算符</p>
<p>赋值运算符</p>
<p>比较运算符</p>
<p>逻辑运算符</p>
<p>位运算符</p>
<p>三目算符</p>
<p>选择控制语句</p>
<p>Scanner类</p>
<p>Random类</p>
<p>循环结构</p>
<p>while循环和do–while循环</p>
<p>for循环</p>
</blockquote>
<p><strong>基本数据类型的转换</strong> (上一章也有)</p>
<blockquote>
<ul>
<li>自动转换 范围小的可以向范围大的进行转换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte &lt; short &lt; int &lt; long &lt; floa &lt; double </span><br></pre></td></tr></table></figure>

<ul>
<li>强制转换 范围大的向小的进行转换,需要强制类型转换</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小范围数据类型 标识符 = (小范围数据类型) 变量名称;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="ASCII表"><a href="#ASCII表" class="headerlink" title="ASCII表"></a>ASCII表</h3><blockquote>
<ul>
<li><p>American Standard Code for Information Interchange，美国信息交换标准代码</p>
</li>
<li><p>当输入人类语的时候,操纵系统就会去查询对应的码表, 将这些语言转换为对应二进制,因为是美国人的语言 只有英文,所以ASCII中只有英文和一些标点,每个英文 </p>
<p>字母和符号对应一个字节(8位)的二进制数字 </p>
</li>
<li><p>不需要我们全部记忆,只需大家记住**(0-­9)对应(48-­57), (A­-Z)对应(65-­90),(a-­z)对应(97-­122)**</p>
</li>
<li><p>因为不能识别中文,所以中国编写自己第一张简体中文 <strong>编码表GB2312</strong>(简体中文,符号,日本假名),因为存的字 有限,所以后来<strong>升级成为GBK</strong>(增加繁体中文和少数名族 文字),我们的操作系统,如果设置成中文就是<strong>GBK编码</strong> </p>
</li>
<li><p>因为后来出现了很多码表,所以世界标准组织ISO推出 了<strong>Unicode编码表(万国码表)</strong>,规定一个字符占用两个字 节</p>
</li>
<li><p><strong>可显示字符</strong></p>
</li>
<li><p><img src="https://www.runoob.com/wp-content/uploads/2022/03/ascii-1-1.png" alt="可显示字符"></p>
</li>
<li><h6 id="控制字符"><a href="#控制字符" class="headerlink" title="控制字符"></a>控制字符</h6></li>
<li><p><img src="https://www.runoob.com/wp-content/uploads/2022/03/ascii-2-1.png" alt="控制字符"></p>
</li>
</ul>
</blockquote>
<h3 id="int和char类型数据转换"><a href="#int和char类型数据转换" class="headerlink" title="int和char类型数据转换"></a>int和char类型数据转换</h3><blockquote>
<ul>
<li><strong>char转换成int</strong>,字符型和数值型进行转换的时候都会查 询编码表,由于int4个字节,char2个字节,所以属于<strong>自动的</strong></li>
</ul>
<p>类型转换 </p>
<ul>
<li><p>int转换成char,需要强制类型转换 </p>
</li>
<li><p>如果char是汉字,转换成整数查询的就是Unicode编码表 </p>
</li>
<li><p>char类型的最大整数是65535,因为char没有负数 </p>
</li>
<li><p>char可以直接赋值为Unicode编码,格式为\uxxxx,十六进制</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line">System.out.println(b);<span class="comment">//97 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">97</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> (<span class="type">char</span>)c;</span><br><span class="line">System.out.println(d);<span class="comment">//a </span></span><br><span class="line"><span class="type">char</span> <span class="variable">chineseChar</span> <span class="operator">=</span> <span class="string">&#x27;\u674e&#x27;</span>;</span><br><span class="line">System.out.println(chineseChar);<span class="comment">//李</span></span><br></pre></td></tr></table></figure>

<h3 id="switch-case语句"><a href="#switch-case语句" class="headerlink" title="switch case语句"></a>switch case语句</h3><blockquote>
<ul>
<li>switch后边的表达式只能是整型字符型（byte，short，int，char），枚举类型，其中jdk7之后支持 字符串型</li>
<li>没有遇见break语句会一直运行到switch所有case结束</li>
</ul>
</blockquote>
<h3 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h3><blockquote>
<ul>
<li>属于引用类型,创建的时候需要固定格式 数据类型 变量 名 &#x3D; new 数据类型(); </li>
<li>需要导入所在的包,导包格式: import java.util.Scanner; </li>
<li>创建对象 Scanner sc &#x3D; new Scanner(System.in); </li>
<li>获取输入的整数 int a &#x3D; sc.nextInt(); </li>
<li>获取输入的字符串 String str &#x3D; sc.nextLine(); </li>
<li>注意sc.nextInt()和sc.nextLine()会中断程序</li>
</ul>
</blockquote>
<h4 id="为什么java的scanner方法nextLine第一行执行不了？"><a href="#为什么java的scanner方法nextLine第一行执行不了？" class="headerlink" title="为什么java的scanner方法nextLine第一行执行不了？"></a>为什么java的scanner方法nextLine第一行执行不了？</h4><blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">System.out.println(a);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">System.out.println(str);</span><br><span class="line">sc.close();</span><br><span class="line"></span><br><span class="line">sout:</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>nextInt（）方法会读取下一个int标志性的token,但是标点不会移动到下一行。仍然处在这一行上，当使用nextLine（）方法时会读取该行剩余所有内容，包括换行符，焦点移动到下一行的开头。所以无法读取到下一行输入的String变量。</p>
<p>可以使用next（）方法，next（）方法以换行行为为标记。</p>
</blockquote>
<h3 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h3><blockquote>
<ul>
<li>需要导入所在的包,导包格式:</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random; </span><br></pre></td></tr></table></figure>

<ul>
<li>创建对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">ran</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>获取随机整数范围是[0,50):</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> ran.nextInt(<span class="number">50</span>); </span><br></pre></td></tr></table></figure>

<ul>
<li>获取随机小数范围是[0,1):</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> ran.nextDouble(); </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如何获取一个[a,b]的随机数</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> rand.nextInt(b - a + <span class="number">1</span>) + a; </span><br></pre></td></tr></table></figure>

<ul>
<li>获取99到356的随机整数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> rand.nextInt(<span class="number">356</span> - <span class="number">99</span> + <span class="number">1</span>) + <span class="number">99</span>;</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(<span class="string">&quot;%-14s%-16s\n&quot;</span>,<span class="string">&quot;序号&quot;</span>,<span class="string">&quot;金额（元）&quot;</span>);</span><br><span class="line">System.out.printf(<span class="string">&quot;%-13s%-16.1f\t&quot;</span>,<span class="string">&quot;总金额&quot;</span>,sum);</span><br></pre></td></tr></table></figure>

<h1 id="Day03-循环数组"><a href="#Day03-循环数组" class="headerlink" title="Day03(循环数组)"></a>Day03(循环数组)</h1><blockquote>
<p>Day03(循环+数组)</p>
<p>Scanner问题(next和nextLine和nextInt)</p>
<p>循环控制语句练习</p>
<p>数组</p>
<p>一维数组</p>
<p>JVM的内存划分</p>
<p>一维数组内存原理</p>
<p>二维数组</p>
<p>一维数组和二维数组的内存关系</p>
</blockquote>
<h3 id="Scanner问题-next和nextLine和nextInt"><a href="#Scanner问题-next和nextLine和nextInt" class="headerlink" title="Scanner问题(next和nextLine和nextInt)"></a>Scanner问题(next和nextLine和nextInt)</h3><blockquote>
<p>nextInt只会读取整数,后面的回车不会读取,所以如果出现读取完整数以后,不能读取后面的字符串,在两个读取中间加一句</p>
<p>sc.nextLine();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt(); sc.nextLine();</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">System.out.println(a+<span class="string">&quot;------&quot;</span>+str);</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h3><h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><blockquote>
<ul>
<li><p>数组的声明 类型 [] 数组名; </p>
</li>
<li><p>[ ]在前后没有影响,一般是写在名称前方 </p>
</li>
<li><p>数组的创建 数组名&#x3D; new 类型[数组长度] </p>
</li>
<li><p>定义完数组的时候系统会给数组默认值,叫做动态初始 化,不同的类型初始化的值不同 </p>
</li>
<li><p>数组的遍历 </p>
<ul>
<li><p>普通for循环遍历 </p>
</li>
<li><p>for each遍历:</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123; </span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> a : arr)&#123; </span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a><strong>二维数组</strong></h4><blockquote>
<p>二维数组声明 类型 [][] 数组名; </p>
<p>二维数组的赋值 数组名&#x3D; new 类型长度</p>
<p>一般建议写成 类型 [][] 数组名 &#x3D; new 类型长度</p>
</blockquote>
<h3 id="JVM的内存划分"><a href="#JVM的内存划分" class="headerlink" title="JVM的内存划分"></a>JVM的内存划分</h3><blockquote>
<ul>
<li><p>程序计数器:记录cpu该去执行线程中哪条指令,说白了就是内存和cpu进行通信不需要我们去关心 </p>
</li>
<li><p>本地方法栈:jvm调用操作系统的方法 的区域,如操作系统支持的复制和粘贴不需要我们去关心 </p>
</li>
<li><p>方法栈:执行方法,保存局部变量 </p>
</li>
<li><p>方法区:存储了每个类的信息（包括类的名称、方法信 息、字段信息）、静态变量、常量以及编译器编译后 的代码等 </p>
</li>
<li><p>堆:用来存储对象本身的以及数组</p>
</li>
</ul>
</blockquote>
<p><img src="/../img/jvm.png" alt="jvm"></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDemo</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg s)</span> &#123; </span><br><span class="line">        <span class="type">int</span> [] arr = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">4</span>];</span><br><span class="line">        System.out.println(arr); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>ArrayDemo.class先进入JVM的方法区 </p>
</li>
<li><p>代码执行main方法,main方法复制压栈开始执行 </p>
</li>
<li><p>遇到创建数组的代码,在堆中创建一块内存,开辟4个空 间,给每个变量有个默认值是0 </p>
</li>
<li><p>将数组的首地址给栈中的arr变量,所以这个arr变量就有 了对堆中对象的引用 </p>
</li>
<li><p>代码执行到输出语句,就会输出arr所引用的堆中的内存 地址</p>
</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对引用类型,只要new一次,就代表在堆中开辟内存空间 </span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="一维数组和二维数组的内存关系"><a href="#一维数组和二维数组的内存关系" class="headerlink" title="一维数组和二维数组的内存关系"></a>一维数组和二维数组的内存关系</h3><blockquote>
<ol>
<li><p>class文件先进入方法区 </p>
</li>
<li><p>main压栈执行 </p>
</li>
<li><p>在堆中创建两个数组,并初始化内容为0,各自的地址为 数组中首元素的地址 </p>
</li>
<li><p>在堆中创建一个数组,数组的长度为2,数组的中有两个 对之前的数组的引用 </p>
</li>
<li><p>让arr引用二维数组的地址</p>
</li>
</ol>
</blockquote>
<p><img src="/../img/jvm1.png" alt="jvm1"></p>
<h1 id="Day04-方法-面向对象"><a href="#Day04-方法-面向对象" class="headerlink" title="Day04(方法+面向对象)"></a>Day04(方法+面向对象)</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><blockquote>
<ul>
<li><p>以将这三个方法的方法名称, 保持一致,只要保证,参数类型,参数个数,参数顺序这三 者有一个不同,<strong>系统就不会将这三个方法当作同一个方法</strong>,这种形式叫做方法的重载.。</p>
</li>
<li><p>注意方法的重载跟修饰符,返回值,参数的名称都没有关系,只和方法名称和参数类型,参数个数,参数顺序有关系</p>
</li>
</ul>
</blockquote>
<h3 id="方法调用参数传递的内存原理"><a href="#方法调用参数传递的内存原理" class="headerlink" title="方法调用参数传递的内存原理"></a>方法调用参数传递的内存原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    testMethod(a);</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    a = <span class="number">101</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/..%5Cimg%5Cjvm3.png" alt="jvm3"></p>
<blockquote>
<ul>
<li><p>在main中定义的变量a的值是100 </p>
</li>
<li><p>调用testMethod(a);此时在内存中testMethod压栈执行, 并且将a的值作为参数赋值给方法参数 </p>
</li>
<li><p>在testMethod中修改参数a的值,此时的参数仅仅和main中定义的变量a的值相同,所以修改参数的值,并不会修改main中a的值</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> [] arr2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    testMethod(arr2);</span><br><span class="line">    System.out.println(arr2[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">(<span class="type">int</span> [] arr)</span> &#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//arr = new int []&#123;100,100&#125;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/..%5Cimg%5Cjvm4.png" alt="jvm4"></p>
<blockquote>
<ul>
<li><p>在main中定义的引用类型arr2,初始化内容是1,2,3 </p>
</li>
<li><p>调用testMethod(int [] arr);此时在内存中testMethod压栈执行,并且将arr2的引用的堆中的地址赋值给参数arr </p>
</li>
<li><p>arr和arr2两者只是对同一块堆中的地址有引用 </p>
</li>
<li><p>在testMethod中将引用类型arr[0] &#x3D; 100;实质是修改了堆中那个对象的内容,所以arr2引用的那个堆中的内容就发生了改变 </p>
</li>
<li><p>如果让arr引用新的堆中的内存,并不会影响arr2的引用</p>
</li>
</ul>
</blockquote>
<h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><blockquote>
<ul>
<li><p>面向对象程序设计(Object Oriented Programming）是当前主流的程序设计架构,使我们编程过程更符合人们的日常生活习惯 </p>
</li>
<li><p>面向过程程序设计,简称opp,c语言就是面向过程的编程语言</p>
</li>
<li><p>面向过程思维方式中更多的体现的是执行者（自己做事情），面向对象中更多的体现是指挥者（指挥对象做事情)</p>
</li>
</ul>
</blockquote>
<h3 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h3><blockquote>
<ul>
<li><p>封装</p>
<ul>
<li><p>之前学习的方法,就是将某个功能写成方法, 编写类的过程也是一种封装 </p>
</li>
<li><p>提高了代码的复用性,便于调用者的使用,提高了安全性</p>
</li>
</ul>
</li>
<li><p>继承(后续讲) </p>
</li>
<li><p>多态(后续讲)</p>
</li>
</ul>
</blockquote>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><blockquote>
<ul>
<li><p>类</p>
<p>对某一类有相同特征的事物的抽象,例如建造房子时设计的模型 </p>
</li>
<li><p>对象</p>
<p>表示现实中该类事物的个体,就是类的具体实现,例如 已经建造成的一个房子 </p>
</li>
<li><p>属性</p>
<p>该类事物的共有的特征,实际就是我们之前所学习的变 量,只不过和之前学过的变量稍有区别 </p>
</li>
<li><p>该类事物共有的功能</p>
</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意:我们程序的入口仍然是main,所以要想对成员变量 赋值,以及调用方法,需要在main中写具体的赋值和调用</span><br></pre></td></tr></table></figure>



<h3 id="类与方法调用过程的内存分析"><a href="#类与方法调用过程的内存分析" class="headerlink" title="类与方法调用过程的内存分析"></a>类与方法调用过程的内存分析</h3><p><img src="/../img/jvm5.png" alt="jvm5"></p>
<blockquote>
<ol>
<li><p>class被加载到内存中的方法区,所以在方法区中就有类 的所有信息 </p>
</li>
<li><p>main方法压栈执行 </p>
</li>
<li><p>People对象在堆中创建,初始化成员变量age为0,height为0.0,weight为0.0 </p>
</li>
<li><p>栈中的pe引用堆中的People的内存地址 </p>
</li>
<li><p>将堆中的People对象的age赋值为12,height赋值为175,weight为175 </p>
</li>
<li><p>eat方法压栈执行,输出”吃饱就开心” </p>
</li>
<li><p>eat方法出栈 </p>
</li>
<li><p>main方法出栈,方法结束</p>
</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意每次new对象,都会从堆内存中创建新的对象</span><br></pre></td></tr></table></figure>

<h3 id="private关键字"><a href="#private关键字" class="headerlink" title="private关键字"></a>private关键字</h3><blockquote>
<ul>
<li><p>private是修饰符,使用private修饰的成员变量或者方法 <strong>只能在当前类中使用</strong> </p>
</li>
<li><p>所以使用private修饰后的成员变量就不能在其他类中访问</p>
</li>
</ul>
</blockquote>
<p>this关键字</p>
<blockquote>
<p>this关键字出现在方法中, 表示当前类的对象, 一个类可以有多个对象, 谁调用的方法,this指的就是谁 </p>
</blockquote>
<h1 id="Day05-继承"><a href="#Day05-继承" class="headerlink" title="Day05(继承)"></a>Day05(继承)</h1><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote>
<p>继承是描述类与类之间的所属关系,通过类的继承可以 形成一个关系体系 </p>
<p>注意:java的class是单继承不是多继承;因为子类可以 继承父类的所有功能,如果有两个父类的功能名称都相 同,那么子类继承后调用的方法到底是哪个类我们就不清楚</p>
</blockquote>
<blockquote>
<ul>
<li><p>一个文件中可以同时声明多个类,但是最多只能有一个 </p>
</li>
<li><p>public的类,如果是public则必须和文件名称保持一致 </p>
</li>
<li><p>格式为: class 子类 extends 父类{}子类拥有父类的成员变量和方法</p>
</li>
</ul>
</blockquote>
<h3 id="继承关系的成员变量特点"><a href="#继承关系的成员变量特点" class="headerlink" title="继承关系的成员变量特点"></a><strong>继承关系的成员变量特点</strong></h3><blockquote>
<ul>
<li><p>父类的成员变量非私有,子类才能直接继承,如果父类成 员变量私有,子类不能直接使用,但是子类是存在这个成员变量的 </p>
</li>
<li><p><strong>如果子类定义了相同的成员变量,那么子类用的是自己 的,而不是父类的</strong> </p>
</li>
<li><p>如果子类要使用父类的成员变量,使用super关键字进行调用,格式为 <em>super.成员变量名称</em></p>
</li>
</ul>
</blockquote>
<h3 id="继承关系的成员方法特点"><a href="#继承关系的成员方法特点" class="headerlink" title="继承关系的成员方法特点"></a><strong>继承关系的成员方法特点</strong></h3><blockquote>
<ul>
<li><p>父类的成员方法非私有,子类才能直接继承 </p>
</li>
<li><p>如果子类定义了父类相同的方法,叫做方法的重写,当子 类对象进行方法调用的时候优先调用子类的方法,如果 子类中没有就回去父类中</p>
</li>
<li><p>如果我们子类重写父类方法的时候,使用eclipse的提示 功能让系统帮我们生成重写方法的时候会出现 @Override,是为了增强编译性的,@Override下的方法 父类必须有,如果没有就报错 </p>
</li>
<li><p>如果子类要使用父类的成员方法,使用super关键字进行调用,格式为 <em>super.方法名称(方法参数);</em></p>
</li>
</ul>
</blockquote>
<h1 id="Day06-抽象类-接口"><a href="#Day06-抽象类-接口" class="headerlink" title="Day06(抽象类+接口)"></a>Day06(抽象类+接口)</h1><blockquote>
<p>Day06(抽象类+接口) </p>
<p>抽象类</p>
<p>抽象类的格式 </p>
<p>抽象类的特点 </p>
<p>抽象类的注意问题 </p>
<p>接口</p>
<p>接口的定义 </p>
<p>接口的实现 </p>
<p>接口的特点 </p>
<p>接口可以多继承(了解即可) </p>
<p>接口的意义 </p>
<p>接口和抽象类区别(面试题)!!! </p>
<p>多态</p>
<p>定义格式 </p>
<p>多态的特点 </p>
<p>多态的转型 </p>
<p>instanceof关键字 </p>
<p>构造方法 </p>
<p>构造方法的格式 </p>
<p>构造方法的特点 </p>
<p>默认构造方法 </p>
<p>子父构造方法的调用 </p>
</blockquote>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><blockquote>
<p>​		当我们定义一个父类的时候,有些方法可能需要子类去 做具体的功能,而在父类中并不能确定做哪些功能,那 么我们就可以将这些方法定义成抽象方法.所谓的抽象 方法就是没有方法体的方法.那么我们的类也必须定义这个类为抽象的类.</p>
</blockquote>
<h3 id="抽象类的格式"><a href="#抽象类的格式" class="headerlink" title="抽象类的格式"></a><strong>抽象类的格式</strong></h3><blockquote>
<ul>
<li><p>抽象方法和抽象类需要使用特定的修饰符进行修饰,这 个修饰符就是 abstract </p>
</li>
<li><p>抽象类的格式为 public abstract class 类名 { } </p>
</li>
<li><p>抽象方法的格式为 </p>
<p>public abstract 返回值类型 方法名(参数);</p>
</li>
</ul>
</blockquote>
<h3 id="抽象类的特点"><a href="#抽象类的特点" class="headerlink" title="抽象类的特点"></a><strong>抽象类的特点</strong></h3><blockquote>
<ul>
<li><p>抽象类和抽象方法都需要被abstract修饰。抽象方法一 定要定义在抽象类中。 </p>
</li>
<li><p><strong>抽象类不可以直接创建对象，原因：调用抽象方法没 有意义</strong>。 </p>
</li>
<li><p>只有覆盖了抽象类中所有的抽象方法后，其子类才可以创建对象。否则该子类得定义成抽象类。 </p>
</li>
<li><p>子类重写父类的抽象方法的时候要去掉abstract关键字</p>
</li>
</ul>
</blockquote>
<h3 id="抽象关键字abstract不可以和哪些关键字共存？"><a href="#抽象关键字abstract不可以和哪些关键字共存？" class="headerlink" title="抽象关键字abstract不可以和哪些关键字共存？"></a>抽象关键字abstract不可以和哪些关键字共存？</h3><blockquote>
<ol>
<li>private：私有的方法子类是无法继承到的，也不 存在覆盖，而abstract和private一起使用修饰方 法，abstract既要子类去实现这个方法，而private 修饰子类根本无法得到父类这个方法。互相矛盾。</li>
<li>final:因为被final定义的方法不能被重写,而抽象方 法需要子类去重写进行实现功能,所以矛盾</li>
<li>static:因为static不用实例化可直接调用,即当前类就直接能够调用了,而abstract需要子类实现后才能调用,所以矛盾</li>
</ol>
</blockquote>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><blockquote>
<ul>
<li><p>与定义类的class不同，接口定义时需要使用interface </p>
</li>
<li><p>关键字 </p>
</li>
<li><p>定义格式:</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名 &#123; </span><br><span class="line">	抽象方法<span class="number">1</span>;</span><br><span class="line">    抽象方法<span class="number">2</span>;</span><br><span class="line">    抽象方法<span class="number">3</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>因为接口是供别的类去实现的,并且要实现他的抽象方法的,所以接口中方法的<strong>访问修饰符必须定义成public</strong> </li>
<li>接口中不能定义普通的成员变量,<strong>只能定义成public static final 成员变量</strong> </li>
<li>接口当中不能定义普通成员方法</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>当一个类需要去实现一个接口时，如果该类实现了接口中的所有方法，则该类既可以定义为实体类也可以定义为抽象类.</li>
<li>如果该类实现了接口中的部分方法，还有部分方法没有实现，没有实现的部分方法只能继续以抽象方法的形式存在该类中，<strong>则该类必须定义为抽象类。</strong></li>
<li>这么做的目的是：当我们需要定义一个类去实现接口中的部分方法时，我们可以先通过抽象类来实现其它部分的方法，然后去继承这个抽象类，就可以达到只实现接口中部分方法的目的；</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意如果定义方法的时候,不写public abstract,语法不 会报错,但是系统会默认添加;定义静态最终成员变量 的时候如果不写public static final,语法不会报错,但是 系统同样会默认添加</span><br></pre></td></tr></table></figure>

<h3 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a><strong>接口的实现</strong></h3><blockquote>
<p>一个类实现接口的格式为:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 类 implements 接口1,接口2 &#123;</span><br><span class="line">	重写接口中方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>一个类可以同时实现多个接口,但是需要将抽象方法进 行实现,创建接口的时候修饰符可以省略, 系统会自动加 上,但是<strong>实现的时候,就必须要添加public</strong></li>
</ul>
</blockquote>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><blockquote>
<ul>
<li>通过继承我们实现了,男人和女人都是人,一个人的类,出现了多种形态,我们称之为这种现象就是java的多态</li>
<li><strong>多态的表现形式为父类的变量指向子类的对象</strong> </li>
<li>多态的前提是必须有子父类关系或者类实现接口关系，否则无法完成多态。 </li>
<li>父类类型的变量调用方法的时候,实际上会调用子类重 写的方法</li>
</ul>
</blockquote>
<h3 id="定义格式"><a href="#定义格式" class="headerlink" title="定义格式"></a><strong>定义格式</strong></h3><blockquote>
<ul>
<li>普通类多态定义的格式 父类 变量名 &#x3D; new 子类();</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;&#125; <span class="comment">//类的多态使用 </span></span><br><span class="line"><span class="type">Fu</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>抽象类多态定义的格式:</p>
<p>抽象类 变量名 &#x3D; new 抽象类子类();</p>
</li>
<li><p>接口多态定义的格式: </p>
<p>接口 变量名 &#x3D; new 接口实现类();</p>
</li>
<li><p>注意:同一个父类的方法会被不同的子类重写。在调用方法时，调用的为各个子类重写后的方法。</p>
</li>
</ul>
</blockquote>
<h3 id="多态的运行特点"><a href="#多态的运行特点" class="headerlink" title="多态的运行特点"></a><strong>多态的运行特点</strong></h3><blockquote>
<ul>
<li><p>对于成员方法:</p>
<p>编译的时候看&#x3D;左边,运行的时候看&#x3D;右边 </p>
</li>
<li><p>对于成员变量:</p>
<p>编译的时候看&#x3D;左边,运行的时候看&#x3D;左边</p>
</li>
</ul>
</blockquote>
<h3 id="多态的转型"><a href="#多态的转型" class="headerlink" title="多态的转型"></a><strong>多态的转型</strong></h3><blockquote>
<ul>
<li><p>如果是多态的话,<strong>程序在进行编译的时候只会看变量的类型,而实际运行的时候则是看具体的对象,<strong>那么如果想要</strong>调用父类中没有而子类中有的方法怎么办?</strong> </p>
</li>
<li><p>可以使用强制转换,也叫做多态的向下转型,将父类类型再转换为子类类型 </p>
<p>子类类型 变量 &#x3D; (子类类型) 变量名称</p>
</li>
<li><p>注意:<strong>如果强制转换的话,必须要保证变量原始就是什么类型,否则就会出现异常</strong></p>
</li>
</ul>
</blockquote>
<h3 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h3><blockquote>
<ul>
<li><p>如果直接进行强制转换的时候有可能会出现问题,所以可以使用instanceof进行判断如 </p>
<p>对象 instanceof 类名 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(a instanceof Zi)&#123; </span><br><span class="line">	Zi z = (Zi) a; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<h1 id="Day07-关键字-常用类"><a href="#Day07-关键字-常用类" class="headerlink" title="Day07(关键字+常用类)"></a>Day07(关键字+常用类)</h1><blockquote>
<p>Day07(关键字+常用类) </p>
<p>常用关键字介绍 </p>
<p>super </p>
<p>final </p>
<p>static </p>
<p>代码块</p>
<p>局部代码块 </p>
<p>构造代码块 </p>
<p>静态代码块 </p>
<p>访问修饰符 </p>
<p>系统常用类介绍 </p>
<p>String</p>
<p>equal方法 </p>
<p>构造方法 </p>
<p>获取字符串的长度 </p>
<p>截取字符串 </p>
<p>是否以字符开头和结尾 </p>
<p>索引和包含 </p>
<p>转换字符数组和字节数组 </p>
<p>分割字符串 </p>
<p>转换大小写字符串 </p>
<p>将字符串指定索引转换成char </p>
<p>String的API </p>
<p>StringBuffer </p>
<p>添加,插入,删除,替换 </p>
<p>StringBuilderList接口</p>
<p>ArrayList </p>
<p>添加,插入,删除,替换,查询 </p>
<p>遍历(和数组相同) </p>
<p>Map接口</p>
<p>HashMap </p>
<p>map的添加,删除,查询 </p>
<p>map的遍历 </p>
<p>Date</p>
<p>构造函数 </p>
<p>日期和毫秒的转换 </p>
<p>DateFormat </p>
<p>创建对象 </p>
<p>日期字符串之间的抓换 </p>
<p>Calendar </p>
<p>创建对象 </p>
<p>获取年月日等信息 </p>
<p>指定字段增加值 </p>
<p>设置指定字段的值 </p>
<p>转换为日期对象 </p>
<p>基本数据类型和对应的包装类 </p>
<p>字符串,基本数据类型,包装类型转换 </p>
<p>System </p>
<p>Math </p>
<p>Arrays大数据运算 </p>
<p>BigInteger </p>
<p>BigDecimal </p>
<p>作业 </p>
</blockquote>
<h3 id="常用关键字介绍"><a href="#常用关键字介绍" class="headerlink" title="常用关键字介绍"></a>常用关键字介绍</h3><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><blockquote>
<ul>
<li><p>子类对父类的引用,只能在非静态方法中使用 </p>
</li>
<li><p>引用父类的成员变量的格式为 super.成员变量名称 </p>
</li>
<li><p>引用父类的非静态方法的格式为 super.方法名(参数列表) </p>
</li>
<li><p>引用父类的构造方法的格式为 super(参数列表)</p>
</li>
</ul>
</blockquote>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><blockquote>
<ul>
<li><p>final<strong>修饰类这个类就不能被继承</strong>,但不影响创建对象,如 系统的String类 </p>
</li>
<li><p>final修饰的方法不能被重写,但父类中没有被final修饰方法，子类覆盖后可以加final。 </p>
</li>
<li><p>final修饰局部变量,只能够赋值一次,当修饰的是引用的类型的时候,不能被重新赋值,但是可以修改对象的属性 </p>
</li>
<li><p>final修饰成员变量,必须在定义的时候进行赋值,不会有 自动初始化值,(或者在构造方法中进行赋值)</p>
</li>
</ul>
</blockquote>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><img src="/../img/static.png" alt="static"></p>
<blockquote>
<ul>
<li>被static修饰的成员变量属于类，不属于这个类的某个对象(多个对象共享一个static修饰的成员变量)</li>
<li>被static修饰的成员变量和成员方法建议直接通过类名进行访问,使用对象访问的时候会有警告 </li>
<li>静态方法中只能使用静态成员变量,不能使用this&#x2F;super</li>
</ul>
</blockquote>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a><strong>静态代码块</strong></h3><blockquote>
<ul>
<li><p>定义在类的成员变量位置的用static修饰的代码块</p>
</li>
<li><p>它优先于主方法执行、优先于构造代码块执行，当以任意形式<strong>第一次使用到该类时执行</strong>。 </p>
</li>
<li><p>该类不管创建多少对象，静态代码块只执行一次。 </p>
</li>
<li><p>可用于给静态变量赋值，用来给类进行初始化。</p>
</li>
</ul>
</blockquote>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a><strong>访问修饰符</strong></h3><table>
<thead>
<tr>
<th align="center">-</th>
<th align="center">public</th>
<th align="center">protected</th>
<th align="center">default</th>
<th align="center">private</th>
</tr>
</thead>
<tbody><tr>
<td align="center">同一类中</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="center">同一包中（子类与无关类）</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">不同包中的子类</td>
<td align="center">✓</td>
<td align="center">✓</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">不同包中的无关类</td>
<td align="center">✓</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p>注意对于protected不同包中的子类只能在子类内部调用,在外部子类是无法调用成员变量和方法的 </p>
</blockquote>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><blockquote>
<ul>
<li>属于不可变字符串,是字符串常量</li>
</ul>
</blockquote>
<blockquote>
<p> equal方法 </p>
</blockquote>
<blockquote>
<ul>
<li>比较两个对象的内容是否相同,&#x3D;&#x3D;是比较两个对象的内 存地址是否相同</li>
<li>常量都是存在jvm,方法区的常量池当中</li>
</ul>
</blockquote>
<blockquote>
<p>截取字符串(substring)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> str.substring(<span class="number">1</span>); </span><br><span class="line"><span class="comment">//返回一个新 字符串，为指定索引后的内容 </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> str.substring(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">//返回一个 新字符串，内容为指定位置开始到指定位置结束所有字 符[2,4) System.out.println(s1);//bcde System.out.println(s2);//cd</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>是否以字符开头和结尾** (startsWith&amp;endsWith)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;zhiyou&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> str.startsWith(<span class="string">&quot;zhi&quot;</span>); </span><br><span class="line"><span class="type">boolean</span> <span class="variable">b3</span> <span class="operator">=</span> str.endsWith(<span class="string">&quot;you&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>索引和包含(indexOf &amp; contains)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abcde&quot;</span>; </span><br><span class="line"><span class="comment">//返回指定字符串的索引值,不包含则返回-1 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> str.indexOf(“bcd”); </span><br><span class="line"><span class="comment">//判断是否包含指定字符串，包含返回true，不包含返回false </span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> str.contains(<span class="string">&quot;bcd&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>转换字符数组和字节数组</strong> </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abcde&quot;</span>; </span><br><span class="line"><span class="type">char</span>[] chs = str.toCharArray(); </span><br><span class="line"><span class="type">byte</span>[] bytes = str.getBytes();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>分割字符串</strong> </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;1-2-3-4-5&quot;</span>; </span><br><span class="line"><span class="comment">/*&#123;&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;&#125;*/</span> System.out.println(s5.split(<span class="string">&quot;-&quot;</span>).length); <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;www.zhiyou.com&quot;</span>; <span class="comment">//&#123;&quot;www&quot;,&quot;zhiyou&quot;,&quot;com&quot;&#125; </span></span><br><span class="line"><span class="comment">/*注意使用.进行分割时候需要使用转义字符,使用\\. */</span></span><br><span class="line">System.out.println(s6.split(<span class="string">&quot;\\.&quot;</span>).lengt h);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将字符串指定索引转换成char</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> str.charAt(i);</span><br></pre></td></tr></table></figure>

<h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><blockquote>
<p>StringBuffer叫做字符串缓冲区,是一个容器,里面存放了很多字符串. </p>
</blockquote>
<blockquote>
<p>添加,插入,删除, 替换</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(); sb.append(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line"><span class="comment">//添加字符串 sb.insert(2, &quot;huhu&quot;);</span></span><br><span class="line"><span class="comment">//索引为2的地方,插入字 符串</span></span><br><span class="line">sb.delete(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">//删除索引为[1,4) </span></span><br><span class="line">sb.replace(<span class="number">1</span>, <span class="number">4</span>, <span class="string">&quot;heihei&quot;</span>);</span><br><span class="line"><span class="comment">//替换范 围[1,4)的内容</span></span><br></pre></td></tr></table></figure>

<p>StringBuilder</p>
<blockquote>
<p>此类提供一个与 StringBuffer 兼容的 API，但是属于线程不安全的,所以效率较高,推荐使用 </p>
</blockquote>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><blockquote>
<p>可以看作是一个容器存储,<strong>只能存储引用类型</strong>,特点是: 有序,带索引,内容可以重复 </p>
</blockquote>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><blockquote>
<ul>
<li><p>ArrayList是List接口的一个实现类 </p>
</li>
<li><p>是一个容器,容器存放的是引用类型,他能够实现动态扩容,内部实现是依靠数组实现的,初始化容量是10,当 要超出容量的时候,扩容变成原来的1.5倍 </p>
</li>
<li><p>创建的格式一般使用多态的形式 List<String> li &#x3D; new ArrayList<String>();</p>
</li>
</ul>
</blockquote>
<p>添加,插入,删除,替换,查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt; (); <span class="comment">//添加 </span></span><br><span class="line">list.add(<span class="string">&quot;李雷&quot;</span>); list.add(<span class="string">&quot;韩梅梅&quot;</span>); </span><br><span class="line"><span class="comment">//插入 插入前[&quot;李雷&quot;,&quot;韩梅梅&quot;] </span></span><br><span class="line">list.add(<span class="number">1</span>, <span class="string">&quot;隔壁老王&quot;</span>); </span><br><span class="line"><span class="comment">//插入元素后的集 合[&quot;李雷&quot;,&quot;隔壁老王&quot;,&quot;韩梅梅&quot;] //删除 </span></span><br><span class="line">list.remove(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 删除元素后的集合[&quot;李 雷&quot;,&quot;隔壁老王&quot;] </span></span><br><span class="line"><span class="comment">//修改 </span></span><br><span class="line">list.set(<span class="number">1</span>, <span class="string">&quot;隔壁老张&quot;</span>);</span><br><span class="line"><span class="comment">// 修改元素后的集 合[&quot;李雷&quot;,&quot;隔壁老张&quot;,&quot;韩梅梅&quot;] //通过索引获取 </span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//获取李雷</span></span><br></pre></td></tr></table></figure>

<p>遍历(和数组相同)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; li.size(); i++)&#123;</span><br><span class="line">    System.out.println(li.get(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(String str : li)&#123; </span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><blockquote>
<p>Map是集合容器,存放的元素由键与值两部分组成，通过键可以找对所对应的值,键和值必须是引用类型,键唯一不能重复,没有顺序 </p>
</blockquote>
<p><img src="/../img/map.png" alt="map"></p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><blockquote>
<p>HashMap是Map的一个实现类 </p>
</blockquote>
<ul>
<li>map的添加,删除,查询</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Map对象 </span></span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;(); </span><br><span class="line"><span class="comment">//给map中添加元素 </span></span><br><span class="line">map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;Monday&quot;</span>); </span><br><span class="line">map.put(<span class="string">&quot;7&quot;</span>, <span class="string">&quot;Sunday&quot;</span>); System.out.println(map); <span class="comment">// </span></span><br><span class="line"><span class="comment">//当给Map中添加元素，会返回key对应的原来的 value值，若key没有对应的值, 返回null</span></span><br><span class="line">System.out.println(map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;Mo n&quot;</span>)); <span class="comment">// </span></span><br><span class="line">Monday System.out.print/.,mbln(map); <span class="comment">// &#123;星期日=Su nday, 星期一=Mon&#125; </span></span><br><span class="line"><span class="comment">//根据指定的key获取对应的value </span></span><br><span class="line"><span class="type">String</span> <span class="variable">en</span> <span class="operator">=</span> map.get(<span class="string">&quot;1&quot;</span>); System.out.println(en); <span class="comment">// Sunday </span></span><br><span class="line"><span class="comment">//根据key删除元素,会返回key对应的value值 </span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.remove(<span class="string">&quot;1&quot;</span>); System.out.println(value); <span class="comment">// Sunday </span></span><br><span class="line">System.out.println(map); <span class="comment">// &#123;1=Mon&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>map的遍历</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;(); <span class="comment">//给map中添加元素 </span></span><br><span class="line">map.put(<span class="string">&quot;邓超&quot;</span>, <span class="string">&quot;孙俪&quot;</span>); </span><br><span class="line">map.put(<span class="string">&quot;李晨&quot;</span>, <span class="string">&quot;范冰冰&quot;</span>); </span><br><span class="line">map.put(<span class="string">&quot;刘德华&quot;</span>, <span class="string">&quot;柳岩&quot;</span>); <span class="comment">//获取Map中的所有key </span></span><br><span class="line">Set&lt;String&gt; keySet = map.keySe <span class="title function_">t</span><span class="params">()</span>; </span><br><span class="line"><span class="keyword">for</span>(String key : keySet)&#123; </span><br><span class="line">    System.out.println(map.get(ke y)) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); System.out.println(date1);<span class="comment">//当前日期 </span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">12354356000000L</span>); System.out.println(date2);<span class="comment">//指定日期</span></span><br></pre></td></tr></table></figure>

<p> 日期和毫秒的转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); </span><br><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> date.getTime(); System.out.println(time);<span class="comment">//1499169262875</span></span><br></pre></td></tr></table></figure>

<p>DateFormat</p>
<blockquote>
<p>格式化日期类,通常用于日期和String的转换 </p>
</blockquote>
<p>创建对象</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>G</td>
<td>年代标识符</td>
</tr>
<tr>
<td>y</td>
<td>年</td>
</tr>
<tr>
<td>M</td>
<td>月</td>
</tr>
<tr>
<td>d</td>
<td>日</td>
</tr>
<tr>
<td>h</td>
<td>时 在上午或者下午（1-12）</td>
</tr>
<tr>
<td>H</td>
<td>时 在一天中（0-23）</td>
</tr>
<tr>
<td>m</td>
<td>分</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
</tr>
<tr>
<td>S</td>
<td>毫秒</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>E</th>
<th>星期</th>
</tr>
</thead>
<tbody><tr>
<td>D</td>
<td>一年中的第几天</td>
</tr>
<tr>
<td>F</td>
<td>一月中的第几个星期几</td>
</tr>
<tr>
<td>w</td>
<td>一年中的第几个星期</td>
</tr>
<tr>
<td>W</td>
<td>一个月中的的第几个星期</td>
</tr>
<tr>
<td>a</td>
<td>上午&#x2F;下午 标记符</td>
</tr>
<tr>
<td>k</td>
<td>时 在一天中（1-24）</td>
</tr>
<tr>
<td>K</td>
<td>时 在上午或下午（0-11）</td>
</tr>
<tr>
<td>z</td>
<td>时区</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); </span><br><span class="line"><span class="comment">//DateFormat抽象类,SimpleDateFormat是DateFormat实现类 </span></span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyy y-MM-dd E HH:mm:ss a&quot;</span>); </span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> df.format(date2); System.out.println(str);</span><br><span class="line"><span class="comment">//2017-07-04 星期 二 20:04:43 下午</span></span><br></pre></td></tr></table></figure>

<p>日期字符串之间的抓换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">12354356000000L</span>); </span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(“yyy y年MM月dd日”); </span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> df.format(date); </span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> ”<span class="number">2020</span>年<span class="number">12</span>月<span class="number">11</span>日”; </span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(“yyy y年MM月dd日”); </span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> df.parse(str);</span><br></pre></td></tr></table></figure>

<h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();</span><br></pre></td></tr></table></figure>

<p>获取年月日等信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance(); </span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> c.get(Calendar.YEAR); </span><br><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> c.get(Calendar.MONTH);</span><br><span class="line"><span class="comment">//从0开 始算起，最大11；0代表1月，11代表12月 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">date</span> <span class="operator">=</span> c.get(Calendar.DATE);</span><br><span class="line"><span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> c.get(Calendar.HOUR); </span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> c.get(Calendar.MINUTE);</span><br><span class="line"><span class="type">int</span> <span class="variable">sec</span> <span class="operator">=</span> c.get(Calendar.SECOND); </span><br><span class="line"><span class="comment">//2017--6--4--8--17--43</span></span><br><span class="line">System.out.println(year+<span class="string">&quot;--&quot;</span>+month+<span class="string">&quot;--&quot;</span>+date+<span class="string">&quot;--&quot;</span>+hour+<span class="string">&quot;--&quot;</span>+min+<span class="string">&quot;--&quot;</span>+sec);</span><br></pre></td></tr></table></figure>

<p>指定字段增加</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="comment">//修改当前时间为3天后 </span></span><br><span class="line">c.add(Calendar.DATE, <span class="number">3</span>); </span><br><span class="line"><span class="comment">//修改当前时间为5小时后 </span></span><br><span class="line">c.add(Calendar.HOUR, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>转换为日期对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance(); </span><br><span class="line"><span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> c.getTime();</span><br></pre></td></tr></table></figure>

<p>使用日历计算平年闰年更为方便 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance(); c.set(<span class="number">2000</span>, <span class="number">2</span>, <span class="number">1</span>); </span><br><span class="line">c.add(Calendar.DATE, -<span class="number">1</span>); </span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> c.get(Calendar.DATE); System.out.println(a);</span><br></pre></td></tr></table></figure>

<h3 id="基本数据类型和对应的包装类"><a href="#基本数据类型和对应的包装类" class="headerlink" title="基本数据类型和对应的包装类"></a>基本数据类型和对应的包装类</h3><p>包装类的作用实现基本数据类型和字符串之间的转换</p>
<table>
<thead>
<tr>
<th align="center">基本数据类型</th>
<th align="center">包装类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">Byte</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">Character</td>
</tr>
</tbody></table>
<p>字符串,基本数据类型,包装类型转换</p>
<ul>
<li><p>字符串转换基本数据类型需要调用包装类 </p>
<p>包装类.parse基本数据类型(“字符串”); </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = Integer.parseInt(&quot;12&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>基本数据类型转换字符串 </p>
<p>String str &#x3D; “”+基本数据类型; 或者 </p>
<p>String str &#x3D;String.valueOf(34); </p>
</li>
<li><p>基本数据类型转换包装类型: </p>
<p>Integer obj &#x3D; Interger.valueOf(3); </p>
</li>
<li><p>包装类型转换基本数据类型: </p>
<p>int a &#x3D;obj.intValue(); </p>
</li>
<li><p>jdk1.5以后系统提供自动装箱:int和integer可以自动转 </p>
<p>换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer i = 4;</span><br><span class="line">//Integer i = Integer.value Of(4); </span><br><span class="line">i = i + 5; </span><br><span class="line">//i.intValue() + 5; </span><br><span class="line">//加法运算完成后，再次装 箱，把基本数值转成对象。</span><br></pre></td></tr></table></figure>

<h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><blockquote>
<ul>
<li><p>获取当前时间的毫秒值 </p>
</li>
<li><p>结束当前程序 </p>
</li>
<li><p>数组的拷贝</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.currentTimeMill <span class="title function_">is</span><span class="params">()</span>);</span><br><span class="line"><span class="comment">//取当前系统时间与1970年01月01日00:00点 之间的毫秒差值 </span></span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//结束程序,通常传入0记为正常状 态，其他为异常状态 </span></span><br><span class="line"><span class="type">int</span>[] src = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; </span><br><span class="line"><span class="type">int</span>[] dest = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;; </span><br><span class="line"><span class="comment">//源数组,源数组的起始位置,目标数组,目标数组的起 始位置,目标数组的长度 </span></span><br><span class="line">System.arraycopy( src, <span class="number">0</span>, dest, <span class="number">0</span>, <span class="number">3</span>); </span><br><span class="line"><span class="comment">//src数组元素[1,2,3,4,5] </span></span><br><span class="line"><span class="comment">//dest数组元素[1,2,3,9,10]</span></span><br></pre></td></tr></table></figure>

<h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><ul>
<li>abs方法,结果都为正数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> Math.abs(-<span class="number">5</span>); <span class="comment">// d1的值为5 </span></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> Math.abs(<span class="number">5</span>); <span class="comment">// d2的值为5</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ceil方法，结果为比参数值大的最小整数的double值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> Math.ceil(<span class="number">3.3</span>); </span><br><span class="line"><span class="comment">//d1的值为 4.0 </span></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> Math.ceil(-<span class="number">3.3</span>); </span><br><span class="line"><span class="comment">//d2的值为 -3.0 </span></span><br><span class="line"><span class="type">double</span> <span class="variable">d3</span> <span class="operator">=</span> Math.ceil(<span class="number">5.1</span>); </span><br><span class="line"><span class="comment">// d3的值为 6.0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>floor方法，结果为比参数值小的最大整数的double值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> Math.floor(<span class="number">3.3</span>); </span><br><span class="line"><span class="comment">//d1的值为3.0 </span></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> Math.floor(-<span class="number">3.3</span>); </span><br><span class="line"><span class="comment">//d2的值 为-4.0 </span></span><br><span class="line"><span class="type">double</span> <span class="variable">d3</span> <span class="operator">=</span> Math.floor(<span class="number">5.1</span>); </span><br><span class="line"><span class="comment">//d3的值为 5.0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>max方法，返回两个参数值中较大的值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> Math.max(<span class="number">3.3</span>, <span class="number">5.5</span>); </span><br><span class="line"><span class="comment">//d1的值为 5.5 </span></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> Math.max(-<span class="number">3.3</span>, -<span class="number">5.5</span>); </span><br><span class="line"><span class="comment">//d2的 值为-3.3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>min方法，返回两个参数值中较小的值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> Math.min(<span class="number">3.3</span>, <span class="number">5.5</span>); </span><br><span class="line"><span class="comment">//d1的值为 3.3 </span></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> Math.max(-<span class="number">3.3</span>, -<span class="number">5.5</span>); </span><br><span class="line"><span class="comment">//d2的 值为-5.5</span></span><br></pre></td></tr></table></figure>

<ul>
<li>pow方法，返回第一个参数的第二个参数次幂的值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> Math.pow(<span class="number">2.0</span>, <span class="number">3.0</span>); </span><br><span class="line"><span class="comment">//d1的值为 8.0 </span></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> Math.pow(<span class="number">3.0</span>, <span class="number">3.0</span>); </span><br><span class="line"><span class="comment">//d2的值为 27.0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>round方法，返回参数值四舍五入的结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> Math.round(<span class="number">5.5</span>); </span><br><span class="line"><span class="comment">//d1的值为6.0 </span></span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> Math.round(<span class="number">5.4</span>); </span><br><span class="line"><span class="comment">//d2的值为5.0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>random方法，产生一个大于等于0.0且小于1.0的double小数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> Math.random();</span><br><span class="line"><span class="comment">//得到的 是[0,1)的小数 </span></span><br><span class="line"><span class="comment">//锁定范围获取 a-b整数 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random()*(b-a+<span class="number">1</span>))+a</span><br></pre></td></tr></table></figure>

<h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a><strong>Arrays</strong></h3><ul>
<li>使用二分查找搜索指定int类型数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;; </span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr, <span class="number">4</span>); <span class="comment">//index的值为2 </span></span><br><span class="line"><span class="type">int</span> index2= Arrasy.binarySearch(arr, <span class="number">2</span>); <span class="comment">//index2的值为-1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>数组升序排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">7</span>&#125;; </span><br><span class="line">Arrays.sort( arr );</span><br></pre></td></tr></table></figure>

<ul>
<li>将数组的内容以字符串形式呈现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">7</span>&#125;; </span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Arrays.toString(arr); </span><br><span class="line"><span class="comment">// str 的值为[1, 3, 5, 7, 9]</span></span><br></pre></td></tr></table></figure>

<h3 id="大数据运算"><a href="#大数据运算" class="headerlink" title="大数据运算"></a><strong>大数据运算</strong></h3><h3 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h3><ul>
<li>大数据整数的加,减,乘,除</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大数据封装为BigInteger对象 </span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">big1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12345 678909876543210&quot;</span>); </span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">big2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;98765 432101234567890&quot;</span>); </span><br><span class="line"><span class="comment">//add实现加法运算 </span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigAdd</span> <span class="operator">=</span> big1.add(big2); </span><br><span class="line">System.out.println(bigAdd); </span><br><span class="line"><span class="comment">//subtract实现减法运算 </span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigSub</span> <span class="operator">=</span> big1.subtract(big <span class="number">2</span>); </span><br><span class="line">System.out.println(bigSub); </span><br><span class="line"><span class="comment">//multiply实现乘法运算 </span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigMul</span> <span class="operator">=</span> big1.multiply(big <span class="number">2</span>);</span><br><span class="line">System.out.println(bigMul); </span><br><span class="line"><span class="comment">//divide实现除法运算 </span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigDiv</span> <span class="operator">=</span> big2.divide(big1); </span><br><span class="line">System.out.println(bigDiv);</span><br></pre></td></tr></table></figure>

<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><ul>
<li>有些时候操作小数的,会出现精度问题如</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">0.09</span>+<span class="number">0.01</span>);</span><br><span class="line"><span class="comment">//0.09999999999999999</span></span><br><span class="line">System.out.println(<span class="number">1.201</span>*<span class="number">100</span>);</span><br><span class="line"><span class="comment">//120.10000 000000001</span></span><br></pre></td></tr></table></figure>

<ul>
<li>大数据小数的加减乘除</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大数据封装为BigDecimal对象 </span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">big1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.09&quot;</span>); </span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">big2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.01&quot;</span>); <span class="comment">//add实现加法运算 </span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bigAdd</span> <span class="operator">=</span> big1.add(big2); </span><br><span class="line">System.out.println(bigAdd ); </span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">big3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>); </span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">big4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.32&quot;</span>); <span class="comment">//subtract实现减法运算 </span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bigSub</span> <span class="operator">=</span> big3.subtract(big4); </span><br><span class="line">System.out.println(bigSub); </span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">big5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.10 5&quot;</span>); </span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">big6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;100&quot;</span>); <span class="comment">//multiply实现乘法运算 </span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bigMul</span> <span class="operator">=</span> big5.multiply(big6); </span><br><span class="line">System.out.println(bigMul); </span><br><span class="line"><span class="comment">//divide实现除法 </span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bigDiv</span> <span class="operator">=</span> big5.divide(big6,<span class="number">2</span>,Bi gDecimal.ROUND_UP);</span><br></pre></td></tr></table></figure>

<h1 id="Day56-正则-集合-泛型"><a href="#Day56-正则-集合-泛型" class="headerlink" title="Day56(正则+集合+泛型)"></a>Day56(正则+集合+泛型)</h1><blockquote>
<p>正则表达式 </p>
<p>规则</p>
<p>字符类 </p>
<p>预定义字符 </p>
<p>边界匹配 </p>
<p>数量词 </p>
<p>String中正则使用 </p>
<p>练习</p>
<p>答案 </p>
<p>泛型</p>
<p>定义泛型的类 </p>
<p>泛型的通配符 </p>
<p>Collection </p>
<p>关系结构 </p>
<p>常用方法 </p>
<p>迭代器</p>
<p>迭代器的常用api </p>
<p>迭代器的原理 </p>
<p>for­each方法 </p>
<p>List接口</p>
<p>常用方法 </p>
<p>List集合存储数据的结构 </p>
<p>ArrayList实现类 </p>
<p>内部原理 </p>
<p>创建并初始化LinkedList实现类 </p>
<p>常用方法 </p>
<p>内部原理 </p>
<p>Set接口</p>
<p>HashSet </p>
<p>哈希表</p>
<p>hash值 </p>
<p>判断重复的原理 </p>
<p>HashSet存储自定义对象 </p>
<p>LinkedHashSet </p>
<p>TreeSet </p>
<p>Map接口</p>
<p>常用方法 </p>
<p>Map集合的遍历 </p>
<p>HashMap存储自定义键 </p>
<p>LinkedHashMap </p>
<p>TreeMap </p>
<p>Collections工具类 </p>
<p>排序</p>
<p>shuffle随机排序 </p>
<p>binarySearch折半查找 </p>
<p>reverse顺序反转 </p>
</blockquote>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><blockquote>
<p>用一些特殊的符号和数字组成的字符串,具有验证其他字符串的功能,其本质还是字符串 </p>
</blockquote>
<p><strong>字符类</strong></p>
<ul>
<li>字符：x</li>
</ul>
<blockquote>
<p> 含义：代表的是字符x </p>
<p>例如：匹配规则为 “a”，那么需要匹配的字符串内 容就是 ”a” </p>
</blockquote>
<ul>
<li>字符: \</li>
</ul>
<blockquote>
<p>含义：代表的是反斜线字符’\’ </p>
<p>例如：匹配规则为”\” ，那么需要匹配的字符串内 容就是 ”\</p>
</blockquote>
<ul>
<li>字符：\t</li>
</ul>
<blockquote>
<p>含义：制表符 </p>
<p>例如：匹配规则为”\t” ，那么对应的效果就是产生 一个制表符的空间 </p>
</blockquote>
<ul>
<li>字符：\r</li>
</ul>
<blockquote>
<p>含义：回车符\</p>
<p>例如：匹配规则为”\r” ，那么对应的效果就是回车后的效果,光标来到下一行行首 </p>
</blockquote>
<ul>
<li>字符类：[abc]</li>
</ul>
<blockquote>
<p>含义：代表的是字符a、b 或 c,匹配一个字符 </p>
<p>例如：匹配规则为”[abc]” ，那么需要匹配的内容就是字符a，或者字符b，或字符c的一个 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;asda&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;[abc]sda&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> str.matches(regex);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure>



<ul>
<li>字符类：</li>
</ul>
<p>[^ abc  ] </p>
<blockquote>
<p>含义：代表的是除了 a、b 或 c以外的任何字符</p>
<p>例如：匹配规则为”[^abc]”，那么需要匹配的内容就是不是字符a，或者不是字符b，或不是字符c的任意一个字符 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;us&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;[^abc]s&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> str.matches(regex);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure>

<ul>
<li>字符类：[a­zA­Z_0­9]</li>
</ul>
<blockquote>
<p>含义：代表的字母或者数字或者下划线(即单词字 符)</p>
<p>例如：匹配规则为” [a­zA­Z_0­9] “，那么需要匹配 的是一个字母或者是一个数字或一个下滑线 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;zus&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;[0-9a-zA-Z_]us&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> str.matches(regex);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure>

<p><strong>预定义字符</strong></p>
<ul>
<li>预定义字符类：.</li>
</ul>
<blockquote>
<p>含义：代表的是<strong>一个</strong>任何字符 </p>
<p>例如：匹配规则为” . “，那么需要匹配的是一个任意字符。如果，就想使用 . 的话，使用匹配规 则”.”来实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Q&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;.&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">regex1</span> <span class="operator">=</span> <span class="string">&quot;\\.&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> str.matches(regex);</span><br><span class="line">System.out.println(b);</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<ul>
<li>预定义字符类：\d</li>
</ul>
<blockquote>
<p>含义：代表的是 0到9数字，两头的数字包括在 内，相当于[0­9] </p>
<p>例如：匹配规则为”\d “，那么需要匹配的是一个数 字,在字符串中需要添加转义字符 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;1hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">regx</span> <span class="operator">=</span> <span class="string">&quot;[\\d]hello&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> str.matches(regex);</span><br><span class="line">System.out.println(b);</span><br><span class="line">\\<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>预定义字符类：\w</li>
</ul>
<blockquote>
<p>含义：代表的字母或者数字或者下划线(即单词字 符)，相当于[a­-zA-­Z_0­-9] </p>
<p>例如：匹配规则为”\w “，，那么需要匹配的是一个 字母或者是一个数字或一个下滑线 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;_hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">regx</span> <span class="operator">=</span> <span class="string">&quot;[\\w]hello&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> str.matches(regex);</span><br><span class="line">System.out.println(b);</span><br><span class="line">\\<span class="literal">true</span></span><br></pre></td></tr></table></figure>



<p><strong>边界匹配</strong></p>
<ul>
<li>边界匹配器：^</li>
</ul>
<blockquote>
<p>含义：代表的是行的开头</p>
<p>例如：匹配规则为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[abc][<span class="number">0</span>-<span class="number">9</span>]$</span><br></pre></td></tr></table></figure>

<p>，那么需要匹配的内容从[abc]这个位置开始, 相当于左双引号</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;_hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">regx</span> <span class="operator">=</span> <span class="string">&quot;[\\w]hello&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> str.matches(regex);</span><br><span class="line">System.out.println(b);</span><br><span class="line">\\<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>边界匹配器：$</li>
</ul>
<blockquote>
<p>含义：代表的是行的结尾 </p>
<p>例如：匹配规则为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[abc][0-9]$</span><br></pre></td></tr></table></figure>

<p> ，那么需要匹配的内容以[0­9]这个结束, 相当于右双引号 </p>
</blockquote>
<ul>
<li>边界匹配器：\b</li>
</ul>
<blockquote>
<p>含义：代表的是单词边界 </p>
<p>例如：匹配规则为”\b[abc]\b” ，那么代表的是字母 a或b或c的左右两边需要的是非单词字符([a-­zA­Z_0-­9]) </p>
</blockquote>
<p><strong>数量词</strong></p>
<ul>
<li>数量词：X?</li>
</ul>
<blockquote>
<p>含义：代表的是X出现一次或一次也没有 </p>
<p>例如：匹配规则为”a?”，那么需要匹配的内容是一 个字符a，或者一个a都没有。</p>
</blockquote>
<ul>
<li>数量词：X*</li>
</ul>
<blockquote>
<p>含义：代表的是X出现零次或多次</p>
<p>例如：匹配规则为”a*” ，那么需要匹配的内容是多个字符a，或者一个a都没有 </p>
</blockquote>
<ul>
<li>数量词：X+</li>
</ul>
<blockquote>
<p>含义：代表的是X出现一次或多次 </p>
<p>例如：匹配规则为”a+”，那么需要匹配的内容是多 个字符a，或者一个a</p>
</blockquote>
<ul>
<li>数量词：X{n}</li>
</ul>
<blockquote>
<p>含义：代表的是X出现恰好 n 次 </p>
<p>例如：匹配规则为”a{5}”，那么需要匹配的内容是5个字符a</p>
</blockquote>
<ul>
<li>数量词：X{n,m}</li>
</ul>
<blockquote>
<p>含义：代表的是X出现至少 n 次，但是不超过 m 次 </p>
<p>例如：匹配规则为”a{5,8}”，那么需要匹配的内容 是有5个字符a 到 8个字符a之间 </p>
</blockquote>
<p><strong>String****中正则使用</strong> </p>
<img src="..\img\regex.png" alt="regex" style="zoom:50%;" />

<p><strong>练习</strong></p>
<blockquote>
<ol>
<li><p>校验qq号码:要求必须是5­-15位数字,0不能开头 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1-9][\\d]&#123;4,14&#125;</span><br><span class="line">[1-9][0-9]&#123;4,14&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>校验手机号码:要求为11位数字,第1位为1，第2位为3、4、5、7、8中的一个，后面9位为0到9之间的任意数字 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1[34578][0-9]&#123;9&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>把文字中的数字替换成* </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s=s.replaceAll(<span class="string">&quot;\\d&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配正整数 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\d+</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配正小数 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\d+\\.\\d+</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配负整数 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-\\d+</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配负小数 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-\\d+\\.\\d+</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配保留两位小数的正数 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\d+\\.\\d&#123;2&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配保留1-­3位小数的正数 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\d+\\.\\d&#123;1,3&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配邮箱 </p>
<p>[1-9]{5,15}@qq.com</p>
</li>
</ol>
</blockquote>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><blockquote>
<p>​		泛型是在在JDK1.5中推出了一种安全机制,我们在使用集合的时候往往要指定集合中存放的数据的类型在java中的泛型实质上是一种伪泛型,是java提供的一种编译手段,如果集合中放的数据类型不是指定类型那么就会编译失败</p>
<p>编译级别的安全机制 </p>
</blockquote>
<p>一、泛型本质</p>
<blockquote>
<p>​		泛型的本质是参数化类型，即给类型指定一个参数，然后在使用时再指定此参数具体的值，那样这个类型就可以在使用时决定了。这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>
</blockquote>
<p><img src="/../img/%E6%B3%9B%E5%9E%8B.png"></p>
<p>二、为什么使用泛型</p>
<blockquote>
<p>​		泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。</p>
</blockquote>
<p><img src="/../img/%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%9C%E7%94%A8.png"></p>
<blockquote>
<ol>
<li>保证了类型的安全性。<br>    在没有泛型之前，从集合中读取到的每一个对象都必须进行类型转换，如果不小心插入了错误的类型对象，在运行时的转换处理就会出错。</li>
</ol>
</blockquote>
<p>比如：没有泛型的情况下使用集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">noGeneric</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">Arraylist</span> <span class="variable">name</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arraylist</span>();</span><br><span class="line">	name.add(<span class="string">&quot;HelloWorld!&quot;</span>);</span><br><span class="line">	name.add(<span class="number">123</span>);<span class="comment">//编译正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有泛型的情况下使用泛型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Arraylist&lt;String&gt; name = <span class="keyword">new</span> <span class="title class_">Arraylist</span>();</span><br><span class="line">	name.add(<span class="string">&quot;HelloWorld!&quot;</span>);</span><br><span class="line">	name.add(<span class="number">123</span>);<span class="comment">//编译异常</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="2">
<li>消除强制转换<br>    泛型的一个附带好处是，消除源代码中的许多强制类型转换，这使得代码更加可读，并且减少了出错机会。</li>
</ol>
</blockquote>
<p>还是举例说明，以下没有泛型的代码段需要强制转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> list.get(<span class="number">0</span>);<span class="comment">//no cast</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> list.get(<span class="number">0</span>);<span class="comment">//normal</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="3">
<li>避免了不必要的装箱、拆箱操作，提高程序的性能<br>    在非泛型编程中，将筒单类型作为Object传递时会引起Boxing（装箱）和Unboxing（拆箱）操作，这两个过程都是具有很大开销的。引入泛型后，就不必进行Boxing和Unboxing操作了，所以运行效率相对较高，特别在对集合操作非常频繁的系统中，这个特点带来的性能提升更加明显。</li>
</ol>
</blockquote>
<p>泛型变量固定了类型，使用的时候就已经知道是值类型还是引用类型，避免了不必要的装箱、拆箱操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//由于是object类型，会自动进行装箱操作。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">int</span>)a;<span class="comment">//强制转换，拆箱操作。这样一来一去，次数多了会影响程序运行效率</span></span><br></pre></td></tr></table></figure>

<p>使用泛型之后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> T GetValue&lt;T&gt;(T a)&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三：如何使用泛型</p>
<blockquote>
<p>​		泛型有三种使用方式，分别为：泛型类、泛型接口和泛型方法。</p>
</blockquote>
<p><img src="/../img/%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8.png"></p>
<h4 id="泛型通常类型参数"><a href="#泛型通常类型参数" class="headerlink" title="泛型通常类型参数"></a>泛型通常类型参数</h4><p>我们都使用大写的单个字母表示</p>
<p>当然，这个后面的参数类型也是有规范的，不能像上面一样随意，<strong>通常类型参数我们都使用大写的单个字母表示</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T: 任意类型 type</span><br><span class="line">E: 集合中元素的类型 element</span><br><span class="line">K: key-value形式 key</span><br><span class="line">V: key-value形式 value</span><br><span class="line">示例：</span><br></pre></td></tr></table></figure>



<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><blockquote>
<p>泛型类：把泛型定义在类上<br>定义格式：</p>
</blockquote>
<p><img src="/../img/%E6%B3%9B%E5%9E%8B%E7%B1%BB.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &lt;泛型类型,...&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：泛型类型必须是引用类型（非基本数据类型）<br>定义泛型类，在类名后添加一对尖括号，并在尖		括号中填写类型参数，参数可以有多个，多个参数使用逗号分隔：<br>public class GenericClass&lt;ab,a,c&gt; {</p>
<p>}</p>
</blockquote>
<p>泛型类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericClass</span>&lt;T&gt;&#123;</span><br><span class="line">	<span class="keyword">private</span> T value;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">GenericClass</span><span class="params">(T value)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        GenericClass&lt;String&gt; test = <span class="keyword">new</span> <span class="title class_">GenericClass</span>&lt;&gt;(<span class="string">&quot;HelloWorld!&quot;</span>);</span><br><span class="line">        System.out.println(test.getValue());</span><br><span class="line">        GenericClass&lt;Integer&gt; test1 = <span class="keyword">new</span> <span class="title class_">GenericClass</span>&lt;&gt;(<span class="number">123</span>);</span><br><span class="line">        System.out.println(test1.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口  :"></a>泛型接口  :</h4><p>概述：把泛型定义在接口上</p>
<img src="../img/泛型接口.png" alt="泛型方法" style="zoom:80%;" />

<p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;泛型类型&gt; 返回类型 方法名(泛型类型 变量名)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意要点：<ul>
<li>方法声明中定义的形参只能在该方法里使用，而接口、类声明中定义的类型形参则可以在整个接口、类中使用。当调用fun()方法时，根据传入的实际对象，编译器就会判断出类型形参T所代表的实际类型。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">GenericInterface</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T value)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringShowImp</span> <span class="keyword">implements</span> <span class="title class_">GenericInterface</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberShowImp</span> <span class="keyword">implements</span> <span class="title class_">GenericInterface</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(Integer value)</span> &#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringShowImp</span> <span class="variable">String</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringShowImp</span>();</span><br><span class="line">        <span class="type">NumberShowImp</span> <span class="variable">Number</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberShowImp</span>();</span><br><span class="line">        String.show(<span class="string">&quot;HelloWorld!&quot;</span>);</span><br><span class="line">        Number.show(<span class="number">123</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：使用泛型的时候，前后定义的泛型类型必须保持一致，否则会出现编译异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GenericInterface&lt;String&gt; gentericInterface = <span class="keyword">new</span> <span class="title class_">NumberShowImp</span>();<span class="comment">//编译异常</span></span><br></pre></td></tr></table></figure>

<p>或者干脆不指定类型，那么 new 什么类型都是可以的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GenericInterface</span> <span class="variable">g1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberShowImp</span>();</span><br><span class="line"><span class="type">GenericInterface</span> <span class="variable">g2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringShowImp</span>();</span><br></pre></td></tr></table></figure>

<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法:"></a>泛型方法:</h4><p>泛型方法，是在调用方法的时候指明泛型的具体类型 。</p>
<p><img src="/../img/%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95.png" alt="泛型方法"></p>
<p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@param t 传入泛型的参数</span></span><br><span class="line"><span class="comment">@param &lt;T&gt; 泛型的类型</span></span><br><span class="line"><span class="comment">@return T 返回值为T类型</span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">	1）public与返回值中间&lt;T&gt;非常重要，可以理解为生命此方法为泛型方法</span></span><br><span class="line"><span class="comment">	2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法</span></span><br><span class="line"><span class="comment">	3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T</span></span><br><span class="line"><span class="comment">	4) 泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">genericMethod</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        System.out.println(t.getClass());</span><br><span class="line">        System.out.println(t);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> genericMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> genericMethod(<span class="number">123</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这里可以看出，泛型方法随着我们的传入参数类型不同，他得到的类型也不同。泛型方法能使方法独立于类而产生变化。</p>
<h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><p>Java泛型的通配符是用于解决泛型之间引用传递问题的特殊语法, 主要有以下三类:</p>
<p><img src="/../img/%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6.png" alt="泛型通配符"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1;表示类型参数可以是任何类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span>&lt;?&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2;表示类型参数必须是A或者是A的子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span>&lt;T <span class="keyword">extends</span> <span class="title class_">A</span>&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3;表示类型参数必须是A或者是A的超类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span>&lt;T supers A&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><p>无边界的通配符(Unbounded Wildcards), 就是<?>, 比如List<?>无边界的通配符的主要作用就是让泛型能够接受未知类型的数据.</p>
</li>
<li><p>固定上边界的通配符(Upper Bounded Wildcards)，采用&lt;? extends E&gt;的形式使用固定上边界的通配符的泛型, 就能够接受指定类及其子类类型的数据。</p>
</li>
</ol>
<p>要声明使用该类通配符, 采用&lt;? extends E&gt;的形式, 这里的E就是该泛型的上边界。注意: 这里虽然用的是extends关键字, 却不仅限于继承了父类E的子类, 也可以代指显现了接口E的类</p>
<ol start="3">
<li><p>固定下边界的通配符(Lower Bounded Wildcards)，采用&lt;? super E&gt;的形式使用固定下边界的通配符的泛型, 就能够接受指定类及其父类类型的数据.。<br> 要声明使用该类通配符, 采用&lt;? super E&gt;的形式, 这里的E就是该泛型的下边界.。</p>
</li>
<li><p><strong>注意: 你可以为一个泛型指定上边界或下边界, 但是不能同时指定上下边界。</strong></p>
</li>
</ol>
</blockquote>
<h4 id="泛型中KTVE的含义"><a href="#泛型中KTVE的含义" class="headerlink" title="泛型中KTVE的含义"></a>泛型中KTVE的含义</h4><p>果点开JDK中一些泛型类的源码，我们会看到下面这些代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Arraylist</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;,RandomAccess,Cloneable,java.io.Serializable&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;k,V&gt;,Cloneable,Serializable&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这些泛型类定义中的泛型参数E、K和V都是什么意思呢？</p>
<blockquote>
<p>其实这些参数名称是可以任意指定，就想方法的参数名一样可以任意指定，但是我们通常会起一个有意义的名称，让别人一看就知道是什么意思。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">常见泛型参数名称有如下：</span><br><span class="line">E：Element (在集合中使用，因为集合中存放的是元素)</span><br><span class="line">T：Type（Java 类）</span><br><span class="line">K：Key（键）</span><br><span class="line">V：Value（值）</span><br><span class="line">N：Number（数值类型）</span><br><span class="line">？：表示不确定的java类型</span><br></pre></td></tr></table></figure>

<h4 id="泛型的实现原理"><a href="#泛型的实现原理" class="headerlink" title="泛型的实现原理"></a>泛型的实现原理</h4><p>泛型本质是<strong>将数据类型参数化</strong>，它通过<strong>擦除</strong>的方式来实现，即编译器会在编译期间「擦除」泛型语法并相应的做出一些类型转换动作。</p>
<p>看一个例子就应该清楚了，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Caculate</span>&lt;T&gt;&#123;</span><br><span class="line">	<span class="keyword">private</span> T num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们定义了一个泛型类，定义了一个属性成员，该成员的类型是一个泛型类型，这个 T 具体是什么类型，我们也不知道，它只是用于限定类型的。</p>
<p>反编译一下这个 Caculate(Caculate.class)类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Caculate</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Caculate</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Object num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现编译器擦除 Caculate 类后面的两个尖括号，并且将 num 的类型定义为 Object 类型。 </p>
<p>那么是不是所有的泛型类型都以 Object 进行擦除呢？</p>
<p>大部分情况下，泛型类型都会以 Object 进行替换，而有一种情况则不是。那就是使用到了extends和super语法的有界类型，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Caculate</span>&lt;T <span class="keyword">extends</span> <span class="title class_">String</span>&gt;&#123;</span><br><span class="line">	<span class="keyword">private</span> T num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况的泛型类型，num 会被替换为 String 而不再是 Object。</p>
<blockquote>
<p>这是一个类型限定的语法，它限定 T 是 String 或者 String 的子类，也就是你构建 Caculate 实例的时候只能限定 T 为 String 或者 String 的子类，所以无论你限定 T 为什么类型，String 都是父类，不会出现类型不匹配的问题，于是可以使用 String 进行类型擦除。</p>
</blockquote>
<h4 id="泛型翻译"><a href="#泛型翻译" class="headerlink" title="泛型翻译"></a>泛型翻译</h4><blockquote>
<p>实际上编译器会正常的将使用泛型的地方编译并进行类型擦除，然后返回实例。但是除此之外的是，如果构建泛型实例时使用了泛型语法，那么编译器将标记该实例并关注该实例后续所有方法的调用，每次调用前都进行安全检查，非指定类型的方法都不能调用成功。</p>
<p>实际上编译器不仅关注一个泛型方法的调用，它还会为某些返回值为限定的泛型类型的方法进行强制类型转换，由于类型擦除，返回值为泛型类型的方法都会擦除成 Object 类型，当这些方法<strong>被调用后，编译器会额外插入一行 checkcast 指令用于强制类型转换</strong>，这一个过程就叫做『泛型翻译』。</p>
</blockquote>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>参考：<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/6824.html">http://c.biancheng.net/view/6824.html</a></p>
<blockquote>
<p>在编程时，可以使用数组来保存多个对象，但数组长度不可变化，一旦在初始化数组时指定了数组长度，这个数组长度就是不可变的。如果需要<strong>保存数量变化的数据，数组就有点无能为力了。</strong>而且数组无法保存具有映射关系的数据，如成绩表为语文——79，数学——80，这种数据看上去像两个数组，但这两个数组的元素之间有一定的关联关系。</p>
<p><strong>为了保存数量不确定的数据，以及保存具有映射关系的数据</strong>（也被称为关联数组），Java 提供了集合类。集合类主要负责保存、盛装其他数据，因此集合类也被称为容器类。Java 所有的集合类都位于 java.util 包下，提供了一个表示和操作对象集合的统一构架，包含大量集合接口，以及这些接口的实现类和操作它们的算法。</p>
<p>集合类和数组不一样，<strong>数组元素既可以是基本类型的值，也可以是对象（实际上保存的是对象的引用变量），而集合里只能保存对象</strong>（实际上只是保存对象的引用变量，但通常习惯上认为集合里保存的是对象）。</p>
<p><strong>Java 集合类型分为 Collection 和 Map</strong>，它们是 Java 集合的根接口，这两个接口又包含了一些子接口或实现类。图 1 和图 2 分别为 Collection 和 Map 的子接口及其实现类。 </p>
</blockquote>
<p> Collection接口基本结构</p>
<p><img src="/../img/Collection.png" alt=" Collection接口基本结构"></p>
<p>Map接口基本结构</p>
<p><img src="/../img/Map1.png" alt="Map接口基本结构"></p>
<ul>
<li>黄色块为集合的接口，蓝色块为集合的实现类。下表 介绍了这些接口的作用。</li>
</ul>
<h4 id="Collection与Map接口与各自实现类作用"><a href="#Collection与Map接口与各自实现类作用" class="headerlink" title="Collection与Map接口与各自实现类作用"></a>Collection与Map接口与各自实现类作用</h4><table>
<thead>
<tr>
<th>接口名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Iterator 接口</td>
<td>集合的输出接口，主要用于遍历输出（即迭代访问）Collection 集合中的元素，Iterator 对象被称之为迭代器。迭代器接口是集合接口的父接口，实现类实现 Collection 时就必须实现 Iterator 接口。</td>
</tr>
<tr>
<td>Collection 接口</td>
<td>是 List、Set 和 Queue 的父接口，是存放一组单值的最大接口。所谓的单值是指集合中的每个元素都是一个对象。一般很少直接使用此接口直接操作。</td>
</tr>
<tr>
<td>Queue 接口</td>
<td>Queue 是 Java 提供的队列实现，有点类似于 List。</td>
</tr>
<tr>
<td>Dueue 接口</td>
<td>是 Queue 的一个子接口，为双向队列。</td>
</tr>
<tr>
<td>List 接口</td>
<td>是最常用的接口。是有序集合，允许有相同的元素。使用 List 能够精确地控制每个元素插入的位置，用户能够使用索引（元素在 List 中的位置，类似于数组下标）来访问 List 中的元素，与数组类似。</td>
</tr>
<tr>
<td>Set 接口</td>
<td>不能包含重复的元素。</td>
</tr>
<tr>
<td>Map 接口</td>
<td>是存放一对值的最大接口，即接口中的每个元素都是一对，以 key→value 的形式保存。</td>
</tr>
</tbody></table>
<blockquote>
<p>对于 Set、List、Queue 和 Map 这 4 种集合，Java 最常用的实现类分别是 HashSet、TreeSet、ArrayList、ArrayDueue、LinkedList 和 HashMap、TreeMap 等。下表介绍了集合中这些常用的实现类。</p>
</blockquote>
<p>Java集合实现类的作用</p>
<table>
<thead>
<tr>
<th>类名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>HashSet</td>
<td>为优化査询速度而设计的 Set。它是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，实现比较简单</td>
</tr>
<tr>
<td>TreeSet</td>
<td>实现了 Set 接口，是一个有序的 Set，这样就能从 Set 里面提取一个有序序列</td>
</tr>
<tr>
<td>ArrayList</td>
<td>一个用数组实现的 List，能进行快速的随机访问，效率高而且实现了可变大小的数组</td>
</tr>
<tr>
<td>ArrayDueue</td>
<td>是一个基于数组实现的双端队列，按“先进先出”的方式操作集合元素</td>
</tr>
<tr>
<td>LinkedList</td>
<td>对顺序访问进行了优化，但随机访问的速度相对较慢。此外它还有 addFirst()、addLast()、getFirst()、getLast()、removeFirst() 和 removeLast() 等方法，能把它当成栈（Stack）或队列（Queue）来用</td>
</tr>
<tr>
<td>HsahMap</td>
<td>按哈希算法来存取键对象</td>
</tr>
<tr>
<td>TreeMap</td>
<td>可以对键对象进行排序</td>
</tr>
</tbody></table>
<h4 id="Java-Collection接口详解"><a href="#Java-Collection接口详解" class="headerlink" title="Java Collection接口详解"></a>Java Collection接口详解</h4><blockquote>
<p>Collection 接口是 List、Set 和 Queue 接口的父接口，通常情况下不被直接使用。Collection 接口定义了一些通用的方法，通过这些方法可以实现对集合的基本操作。定义的方法既可用于操作 Set 集合，也可用于操作 List 和 Queue 集合。</p>
</blockquote>
<p>Collection接口的常用方法</p>
<table>
<thead>
<tr>
<th>boolean add(E e)</th>
<th>向集合中添加一个元素，如果集合对象被添加操作改变了，则返回 true。E 是元素的数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>boolean addAll(Collection c)</td>
<td>向集合中添加集合 c 中的所有元素，如果集合对象被添加操作改变了，则返回 true。</td>
</tr>
<tr>
<td>void clear()</td>
<td>清除集合中的所有元素，将集合长度变为 0。</td>
</tr>
<tr>
<td>boolean contains(Object o)</td>
<td>判断集合中是否存在指定元素</td>
</tr>
<tr>
<td>boolean containsAll(Collection c)</td>
<td>判断集合中是否包含集合 c 中的所有元素</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断集合是否为空</td>
</tr>
<tr>
<td>Iterator<E>iterator()</td>
<td>返回一个 Iterator 对象，用于遍历集合中的元素</td>
</tr>
<tr>
<td>boolean remove(Object o)</td>
<td>从集合中删除一个指定元素，当集合中包含了一个或多个元素 o 时，该方法只删除第一个符合条件的元素，该方法将返回 true。</td>
</tr>
<tr>
<td>Object[] toArray()</td>
<td>把集合转换为一个数组，所有的集合元素变成对应的数组元素。</td>
</tr>
<tr>
<td>boolean retainAll(Collection c)</td>
<td>从集合中删除<strong>集合 c 里不包含的元素</strong>（相当于把调用该方法的集合变成该集合和集合 c 的交集），如果该操作改变了调用该方法的集合，则该方法返回 true。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>boolean removeAll(Collection c)</th>
<th>从集合中删除所有在集合 c 中出现的元素（相当于把调用该方法的集合减去集合 c）。如果该操作改变了调用该方法的集合，则该方法返回 true。</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>以上方法完全来自于 <a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> API 文档，读者可自行参考 API 文档</p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a><strong>迭代器</strong></h4><blockquote>
<p>java中提供了很多的集合类型,不同类型的集合存取方 式各不相同,所有的集合都可以通过迭代器来来从中获 取内容,其目的就是为了应对集合的遍历 </p>
<p>迭代器本身是一个接口,我们需要获取其实现 类,Collection接口中提供了一个方法,可以获取迭代器实现类 </p>
</blockquote>
<p><strong>迭代器的原理</strong> </p>
<blockquote>
<p>当集合调用iterator()方法获取迭代器的时候,相当于集 合中就存在一个指针,指针指向的是­1位置,hasNext() 方法只判断是否有下一个元素,指针的位置不会发生改 变,next()方法是让指针向下走不能在迭代的过程中去修改集合</p>
</blockquote>
<p>List 实现了 Collection 接口，它主要有两个常用的实现类：ArrayList 类和 LinkedList 类。 </p>
<h4 id="for-­each方法"><a href="#for-­each方法" class="headerlink" title="for-­each方法"></a><strong>for-­each</strong>方法</h4><blockquote>
<p>for­each其内部就是迭代器的原理,实际是在jdk1.5以后推出的,凡是类实现了Iterable接口都可以使用for­-each方法进行遍历,我们所学的所有集合都实现了此接口,所以可以使用这种方法进行遍历 </p>
</blockquote>
<h3 id="List接口-1"><a href="#List接口-1" class="headerlink" title="List接口"></a><strong>List</strong>接口</h3><blockquote>
<p>List接口的父接口是Collection接口,List接口的实现类 </p>
<p>具有以下特性 </p>
<p>​	1.有序(存储数序和读取顺序) </p>
<p>​	2.有索引 </p>
<p>​	3.能够存储重复元素</p>
</blockquote>
<h4 id="List集合存储数据的结构"><a href="#List集合存储数据的结构" class="headerlink" title="List集合存储数据的结构"></a><strong>List</strong>集合存储数据的结构</h4><ul>
<li><p>栈结构</p>
<ul>
<li>特点:先进后出</li>
</ul>
</li>
<li><p>队列结构 </p>
<ul>
<li>特点:先进先出</li>
</ul>
</li>
<li><p>数组</p>
<ul>
<li><p>特点:1.内存地址连续 </p>
</li>
<li><p>特点:2.查找快,可以快速访问指定位置的元素 </p>
</li>
<li><p>特点:3.增删慢,需要创建一个新数组，将指定索引位置插入新元素存储或者删除元素,再把原数组元素根据索引,复制到新数组对应索引的位置。</p>
</li>
</ul>
</li>
<li><p>链表,分为数据域和指针域,数据域中放的是数据,指针域指的是前后节点的信息 </p>
<ul>
<li><p>特点:1.多个节点之间，通过地址进行连接 </p>
</li>
<li><p>特点:2查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素 </p>
</li>
<li><p>特点:3增删元素快</p>
</li>
</ul>
</li>
</ul>
<h4 id="ArrayList-类"><a href="#ArrayList-类" class="headerlink" title="ArrayList 类"></a><strong>ArrayList 类</strong></h4><blockquote>
<p>其结构是**数组,**初始化的数组长度是10,每次添加新的元素都会,进行长度的判断,当符合条件的时候进行数组的动态扩容,是线程不安全的 </p>
</blockquote>
<p>ArrayList 类实现了可变数组的大小，存储在内的数据称为元素。它还提供了快速基于索引访问元素的方式，对尾部成员的增加和删除支持较好。使用 ArrayList 创建的集合，允许对集合中的元素进行快速的随机访问，不过，向 ArrayList 中插入与删除元素的速度相对较慢。</p>
<p>ArrayList 类的常用构造方法有<strong>如下两种重载形式</strong>： </p>
<ul>
<li>ArrayList()：构造一个初始容量为 10 的空列表。</li>
<li>ArrayList(Collection&lt;?extends E&gt;c)：构造一个包含指定 Collection 元素的列表，这些元素是按照该 Collection 的迭代器返回它们的顺序排列的。</li>
</ul>
<blockquote>
<p>通过内部原理可知,对于ArrayList的每次操作,当需要扩 </p>
<p>容的时候,每次扩容为当前长度的1.5倍,,但是每次操作 </p>
<p>集合都需要进行数组的拷贝,此过程消耗资源,所以如 </p>
<p>果对于经常对集合进行添加删除操作的时候,不建议使 </p>
<p>用ArrayList </p>
</blockquote>
<p>ArrayList类的常用方法</p>
<p>​      参考api</p>
<blockquote>
<p>retainAll( ) 方法的作用与 removeAll( ) 方法相反，即保留两个集合中相同的元素，其他全部删除。</p>
</blockquote>
<h4 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a><strong>LinkedList类</strong></h4><blockquote>
<p>LinkedList集合数据存储的结构是<strong>双向链表</strong>结构。方便元素添加、删除的集合。实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。 </p>
</blockquote>
<p>随机访问是指检索集合中特定索引位置的元素。</p>
<blockquote>
<p>通过内部原理可知,链表的添加删除元素比较快,不用经过数组的重复赋值过程,但是查找元素都要从第一个或者最后一个元素进行遍历查找,比较耗费时间</p>
</blockquote>
<p>LinkedList类中的方法</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void addFirst(E e)</td>
<td>将指定元素添加到此集合的开头</td>
</tr>
<tr>
<td>void addLast(E e)</td>
<td>将指定元素添加到此集合的末尾</td>
</tr>
<tr>
<td>E getFirst()</td>
<td>返回此集合的第一个元素</td>
</tr>
<tr>
<td>E getLast()</td>
<td>返回此集合的最后一个元素</td>
</tr>
<tr>
<td>E removeFirst()</td>
<td>删除此集合中的第一个元素</td>
</tr>
<tr>
<td>E removeLast()</td>
<td>删除此集合中的最后一个元素</td>
</tr>
</tbody></table>
<blockquote>
<p>详细参考api</p>
</blockquote>
<h4 id="ArrayList-类和-LinkedList-类的区别"><a href="#ArrayList-类和-LinkedList-类的区别" class="headerlink" title="ArrayList 类和 LinkedList 类的区别"></a><strong>ArrayList 类和 LinkedList 类的区别</strong></h4><blockquote>
<ul>
<li><p>ArrayList 与 LinkedList 都是 List 接口的实现类，因此都实现了 List 的所有未实现的方法，只是实现的方式有所不同。</p>
</li>
<li><p>ArrayList 是基于动态数组数据结构的实现，访问元素速度优于 LinkedList。LinkedList 是基于链表数据结构的实现，占用的内存空间比较大，但在批量插入或删除数据时优于 ArrayList。</p>
</li>
<li><p>对于快速访问对象的需求，使用 ArrayList 实现执行效率上会比较好。需要频繁向集合中插入和删除元素时，使用 LinkedList 类比 ArrayList 类效果高。</p>
</li>
<li><p>不同的结构对应于不同的算法，有的考虑节省占用空间，有的考虑提高运行效率，对于程序员而言，它们就像是“熊掌”和“鱼肉”，不可兼得。高运行速度往往是以牺牲空间为代价的，而节省占用空间往往是以牺牲运行速度为代价的。</p>
</li>
</ul>
</blockquote>
<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a><strong>Set</strong>接口</h3><p>Set 集合类似于一个罐子，程序可以依次把多个对象“丢进”Set 集合，而 Set 集合通常不能记住元素的添加顺序。也就是说 Set 集合中的对象不按特定的方式排序，只是简单地把对象加入集合。Set 集合中不能包含重复的对象，并且最多<strong>只允许包含一个 null 元素。</strong></p>
<p>Set 实现了 Collection 接口，它主要有两个常用的实现类：HashSet 类和 TreeSet类。 </p>
<p>Set接口的特点 </p>
<blockquote>
<pre><code>1. 不包含重复元素的集合
 2. set集合中是没有索引的 
 3. set接口的方法和Collection中的方法完全相同 
</code></pre>
</blockquote>
<h4 id="HashSet-类"><a href="#HashSet-类" class="headerlink" title="HashSet 类"></a><strong>HashSet 类</strong></h4><p>此类实现Set接口,底层的数据结构hash表,此类的特点有</p>
<blockquote>
<ol>
<li>无序的 </li>
<li>不重复 </li>
<li>底层是HashMap </li>
<li>集合元素值可以是 null。</li>
<li>HashSet 不是同步的，如果多个线程同时访问或修改一个 HashSet，则必须通过代码来保证其同步。</li>
<li>当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode 值，然后根据该 hashCode 值决定该对象在 HashSet 中的存储位置。如果有两个元素通过 equals() 方法比较返回的结果为 true，但它们的 hashCode 不相等，HashSet 将会把它们存储在不同的位置，依然可以添加成功。也就是说，<strong>两个对象的 hashCode 值相等且通过 equals() 方法比较返回结果为 true，则 HashSet 集合认为两个元素相等。</strong>在 HashSet 类中实现了 Collection 接口中的所有方法</li>
<li>HashSet 类的常用构造方法重载形式如下。<br>HashSet()：构造一个新的空的 Set 集合。<br>HashSet(Collection&lt;? extends E&gt;c)：构造一个包含指定 Collection 集合元素的新 Set 集合。其中，“&lt; &gt;”中的 extends 表示 HashSet 的父类，即指明该 Set 集合中存放的集合元素类型。c 表示其中的元素将被存放在此 Set 集合中。</li>
</ol>
</blockquote>
<p>HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时就是使用这个实现类。HashSet 是按照 Hash 算法来存储集合中的元素。因此具有很好的存取和查找性能。</p>
<p><strong>HashSet</strong>存储自定义对象</p>
<ul>
<li><p>重写hashcode方法 </p>
</li>
<li><p>重写equals方法</p>
</li>
</ul>
<h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a><strong>LinkedHashSet</strong></h4><blockquote>
<p>其存储结构和HashSet相同,和HashSet不同的是其是有序的 </p>
</blockquote>
<h4 id="TreeSet-类"><a href="#TreeSet-类" class="headerlink" title="TreeSet 类"></a><strong>TreeSet 类</strong></h4><blockquote>
<ul>
<li>是一种红黑树(特殊的二叉树)的结构,其内部是一个排好顺序的结构 </li>
<li>二叉树的先序排序,中序排序,后序排序 </li>
<li><strong>如果TreeSet放自定义对象,需要实现Comparable实现compareTo方法,方法的返回值为正数代表顺序,为负数代表逆序</strong></li>
</ul>
</blockquote>
<h5 id="TreeSet重写Comparator比较器"><a href="#TreeSet重写Comparator比较器" class="headerlink" title="TreeSet重写Comparator比较器"></a><strong>TreeSet重写Comparator比较器</strong></h5><ol>
<li><p>比较器有两种，内部比较器和外部比较器；</p>
</li>
<li><p>内部比较器：定义在要比较的类元素中。</p>
<ul>
<li>接口：Comparable</li>
<li>方法：compareTo(Object o)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt; &#123;<span class="comment">//不要选择java.util.Comparator</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"> 	</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> 	&#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> 	&#123;<span class="comment">//重写compareTo</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getScore()-o.getScore();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>外部比较器：定义在新建的TreeSet集合的构造函数中。</p>
<ul>
<li><p>接口：Comparator<T></p>
</li>
<li><p>方法：compare(T o1, T o2)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;Student&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getScore()-o2.getScore();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>当同时有内部比较器和外部比较器时，外部比较器起作用。</p>
</li>
<li><p>推荐使用外部比较器；</p>
<ul>
<li><p>内部比较器只有在存储当前那对象的时候才可以使用；</p>
</li>
<li><p>外部比较器可以定义为一个工具类，此时所有需要比较的规则如果一致的话，可以复用。</p>
</li>
</ul>
</li>
<li><p>基本数据类型，不需要定义比较器；</p>
<ul>
<li>只有当以树作为存储结构时，而且添加的是引用对象时，才需要定义比较器。</li>
<li>此篇文章举例用TreeSet，TreeSet用TreeMap实现，TreeMap用红黑树实现。而且添加的是自定义的类，所以需要定义比较器。</li>
<li>如果添加的是基本数据类型，不需要定义比较器。</li>
</ul>
</li>
</ol>
<p>TreeSet 类同时实现了 Set 接口和 SortedSet 接口。SortedSet 接口是 Set 接口的子接口，可以实现对集合进行自然排序，因此使用 TreeSet 类实现的 Set 接口默认情况下是自然排序的，这里的自然排序指的是升序排序。</p>
<h3 id="Map接口-1"><a href="#Map接口-1" class="headerlink" title="Map接口"></a><strong>Map</strong>接口</h3><blockquote>
<p>Map接口和Collection接口没有任何关系,Map中存放 的是键值对,键和值都是Object,使用的时候注意键的唯一不重复的特性</p>
<p>Map中常用的实现类为 </p>
<p>HashMap,LinkedHashMap,TreeMap</p>
</blockquote>
<h4 id="Map集合的遍历"><a href="#Map集合的遍历" class="headerlink" title="Map集合的遍历"></a><strong>Map</strong>集合的遍历</h4><blockquote>
<ul>
<li><p>通过keySet集合遍历,通过map调用keySet方法进行遍历</p>
</li>
<li><p>通过Map中的关系对象 Entry 进行遍历, Entry 是定义在Map中的内部类,表示键值对关系的对象,通过entry的getKey() 方法获取对应关系中的键,通过entry的 getValue() 获取对应关系的值</p>
</li>
</ul>
</blockquote>
<h4 id="HashMap存储自定义键"><a href="#HashMap存储自定义键" class="headerlink" title="HashMap存储自定义键"></a><strong>HashMap</strong>存储自定义键</h4><blockquote>
<p>需要定自定义的键的时候,需要重写hashcode和equeals方法 </p>
</blockquote>
<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a><strong>LinkedHashMap</strong></h4><blockquote>
<p>和LinkedHashSet相同,存放的顺序和读取的顺序一致</p>
</blockquote>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a><strong>TreeMap</strong></h4><blockquote>
<p>本质是红黑树,会对key进行默认排序,如果自定义的key,需要实现compareable接口重写compareTo方法 </p>
</blockquote>
<h3 id="Collections-不是Collection-工具类"><a href="#Collections-不是Collection-工具类" class="headerlink" title="Collections(不是Collection)工具类"></a><strong>Collections</strong>(不是Collection)工具类</h3><blockquote>
<p>更多请参考api</p>
</blockquote>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a><strong>排序</strong></h4><ul>
<li>通过调用 Collections.sort() 方法进行排序,默认使用的字符串的ASCII进行排列</li>
</ul>
<p>对于自定义类型排序有两种方式 </p>
<ol>
<li><p>对于类实现接口Comparable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person o)</span> &#123; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.age - o.age; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>调用方法,创建比较器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(li, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Car&gt; () &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Car o1, Ca r o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getPrice() - o <span class="number">2.</span>getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="shuffle随机排序"><a href="#shuffle随机排序" class="headerlink" title="shuffle随机排序"></a><strong>shuffle</strong>随机排序</h4><blockquote>
<p>通过调用 Collections.shuffle(li); 进行随机排序 </p>
</blockquote>
<h4 id="binarySearch折半查找"><a href="#binarySearch折半查找" class="headerlink" title="binarySearch折半查找"></a><strong>binarySearch</strong>折半查找</h4><blockquote>
<p>通过调用 int search &#x3D; Collections.binarySearch(li, “rsaaw”); </p>
</blockquote>
<h4 id="reverse顺序反转"><a href="#reverse顺序反转" class="headerlink" title="reverse顺序反转"></a><strong>reverse</strong>顺序反转</h4><blockquote>
<p>通过调用 Collections.reverse(li); 将集合中的元素反向排列</p>
</blockquote>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h4 id="hashmap和hashset的区别和联系"><a href="#hashmap和hashset的区别和联系" class="headerlink" title="hashmap和hashset的区别和联系"></a>hashmap和hashset的区别和联系</h4><p><strong>hashset</strong></p>
<p>通过查看hashset的add方法源码可以发现hashset采用的是map存储结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>hashset则将对象存储在map的key中，value值用一个new Object()作为填充</p>
</li>
<li><p>往hashset存储元素时，hashset会先调用元素的hashcode方法获取元素的hash值，再用元素的hash值和（数组长度-1）做位运算得到下标</p>
</li>
<li><p>HashMap的底层是一个数组结构，数组中的每一项对应了一个链表（jdk1.8之后是红黑树），这种结构称“链表散列”的数据结构，即数组和链表的结合体；也叫散列表、哈希表。</p>
</li>
<li><p>如果此时计算的位置上没有其他元素则直接插入不用比较。</p>
</li>
<li><p>但是随着元素的不断添加，就可能会出现“哈希冲突”，不同的对象计算出的hashcode是相同的。这时候就需要用equals方法进行比较，如果相同则不插入，如果不同则用头插法插入链表。但是<strong>若相同元素过多</strong>同样会产生链表过长查找慢的问题，在1.8之后就采用了红黑树结构。</p>
</li>
</ul>
</blockquote>
<p><strong>hashmap</strong></p>
<blockquote>
<p>一、HahMap存储对象的过程如下</p>
<ol>
<li><p>对HahMap的Key调用hashCode()方法，返回int值，即对应的hashCode；</p>
</li>
<li><p>把此hashCode作为哈希表的索引，查找哈希表的相应位置，若当前位置内容为NULL，则把hashMap的Key、Value包装成Entry数组，放入当前位置；</p>
</li>
<li><p>若当前位置内容不为空，则继续查找当前索引处存放的链表，利用equals方法，找到Key相同的Entry数组，则用当前Value去替换旧的Value；</p>
</li>
<li><p>若未找到与当前Key值相同的对象，则把当前位置的链表后移（Entry数组持有一个指向下一个元素的引用），把新的Entry数组放到链表表头；</p>
</li>
</ol>
</blockquote>
<p>HashSet和HashMap的区别</p>
<p><img src="/../img/HashSet&HashMap.png" alt="HashSet&amp;HashMap.png"></p>
<p>hashset为什么比hashmap慢呢？</p>
<blockquote>
<p>有的说是因为HashMap可以直接通过hash计算得到的键来获取对象，而HashSet呢， 直接用HashMap的containKeys方法，确实能在相同效率下确定一个元素是否存在，但是因为实现的是set，并不能用get方法，因此取值很麻烦。但是总感觉牵强。</p>
<p>因此就想会不会是因为键值对像的差别造成的，他们俩都必须计算哈希码，但要考虑HashMap的键的性质-它通常是一个简单的String甚至是一个数字。他们俩都必须计算哈希码，而hashset可能会是一个对象。如果HashMap的键与存储在HashSet中的键是相同的对象，则性能将没有真正的区别。区别在于HashMap的键是哪种对象。</p>
</blockquote>
<h1 id="Day57-IO"><a href="#Day57-IO" class="headerlink" title="Day57(IO)"></a>Day57(IO)</h1><blockquote>
<p>Day57(IO)</p>
<p>IO(Input&amp;Output)</p>
<p>File类</p>
<p>路径问题</p>
<p>构造方法</p>
<p>创建删除目录和文件</p>
<p>File的获取功能</p>
<p>File判断功能</p>
<p>遍历目录</p>
<p>文件过滤器</p>
<p>文件过滤原理</p>
<p>输出流和输入流</p>
<p>OutputStream</p>
<p>FileOutputStream</p>
<p>写入流程</p>
<p>写入方式</p>
<p>InputStream</p>
<p>FileInputStream</p>
<p>构造方法</p>
<p>读取方式</p>
</blockquote>
<h2 id="IO-Input-amp-Output"><a href="#IO-Input-amp-Output" class="headerlink" title="IO(Input&amp;Output)"></a>IO(Input&amp;Output)</h2><blockquote>
<p>当需要把内存中的数据存储到持久化设备上这个动作 称为输出（写）Output操作。 </p>
<p>当把持久设备上的数据读取到内存中的这个动作称为输入（读）Input操作。 </p>
</blockquote>
<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a><strong>File</strong>类</h2><blockquote>
<p>当我们要操作系统的<strong>文件和文件夹</strong>的时候就需要使用 java.io包中的File类 </p>
</blockquote>
<h2 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a><strong>路径问题</strong></h2><blockquote>
<ul>
<li>在windows中的路径的分隔符 \ </li>
<li>使用java代码写的时候,因为 \ 就是转义字符,所以应该写成 \ \也可一写成 &#x2F; </li>
<li>在linux中的路径的分隔符是 &#x2F;</li>
</ul>
</blockquote>
<h2 id="File常见属性"><a href="#File常见属性" class="headerlink" title="File常见属性"></a>File常见属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pathSeparator:Windows中等同于\;Linux中\:</span><br><span class="line">Separator:Windows中等同于\\</span><br></pre></td></tr></table></figure>



<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File(String parent, String child)</span><br><span class="line">File(String pathname)</span><br><span class="line">File(URI uri)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:\\test\\2.txt&quot;</span>); System.out.println(file); </span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:\\test&quot;</span>,<span class="string">&quot;2.txt&quot;</span>); </span><br><span class="line">System.out.println(file2); </span><br><span class="line"><span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:\\test&quot;</span>); </span><br><span class="line"><span class="type">File</span> <span class="variable">file4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file3,<span class="string">&quot;2.txt&quot;</span>); System.out.println(file4);</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/01/java%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0/" data-id="cl6yh1c7f000sn4vr6lal80pm" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/08/01/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%80%83%E8%AF%95/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          第一次考试
        
      </div>
    </a>
  
  
    <a href="/2022/08/01/idea%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">idea快捷键大全</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/GitHub/" rel="tag">GitHub</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/" rel="tag">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typora/" rel="tag">Typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VPN/" rel="tag">VPN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/idea/" rel="tag">idea</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">java, 数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu%E5%AE%89%E8%A3%85/" rel="tag">ubuntu安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/" rel="tag">自我介绍</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">计算机操作系统</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/GitHub/" style="font-size: 10px;">GitHub</a> <a href="/tags/HTML5/" style="font-size: 10px;">HTML5</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/Typora/" style="font-size: 10px;">Typora</a> <a href="/tags/VPN/" style="font-size: 10px;">VPN</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/idea/" style="font-size: 10px;">idea</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/java-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">java, 数据结构</a> <a href="/tags/ubuntu%E5%AE%89%E8%A3%85/" style="font-size: 10px;">ubuntu安装</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/" style="font-size: 10px;">自我介绍</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">计算机操作系统</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/08/11/%E6%B3%9B%E5%9E%8B/">泛型</a>
          </li>
        
          <li>
            <a href="/2022/08/08/java%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E6%A1%86%E6%9E%B6/">java集合体系框架</a>
          </li>
        
          <li>
            <a href="/2022/08/08/%E5%93%88%E5%B8%8C%E8%A1%A8/">哈希表</a>
          </li>
        
          <li>
            <a href="/2022/08/04/VPN/">VPN</a>
          </li>
        
          <li>
            <a href="/2022/08/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%B5%AE%E7%82%B9%E6%95%B0%E5%A4%B1%E7%9C%9F%E9%97%AE%E9%A2%98/">计算机浮点数失真问题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>